// Conductor.tjs - KAG シナリオM行I理
// Copyright (C)2001-2006, W.Dee and contributors  改?配布は自由です


class ConductorException extends Exception
{
	// ConductorException - Conductor がタグハンドラをI理中にk生した例外を
	// 投げるrに使われる例外クラス
	function ConductorException() { super.Exception(...); }
	function finalize() { super.finalize(...); }
};

class BaseConductor extends KAGParser
{
	// BaseConductor - シナリオM行I理のベ`スクラス
	var timer;
	var oneshot;
	var _interrupted = false; // 中断中か
	var timerEnabled = false; // タイマが起又肖
	var pendings; // 後回しにされたタグ
	var inProcessing = false; // timerCallback をI理中かどうか
	var reentered = false; // timerCallback 中に 再入したか
	var nextTimerTick = 0; // 次にタイマ`がk婴丹欷毪悉氦 tick

	function BaseConductor()
	{
		// コンストラクタ
		super.KAGParser(...);

		timer = new Timer(timerCallback, '');
			// Timerの第二引数に空文字列を指定すると
			// 第１引数に指定したv数を直接呼び出すようになる
		oneshot = new AsyncTrigger(timerCallback, '');
			// これも同
		oneshot.cached = true; // イベントのキャッシュを有郡

		pendings = [];
	}

	function finalize()
	{
		// finalize()
		invalidate timer;
		invalidate oneshot;
		super.finalize(...);
	}

	function clear()
	{
		// clear オ`バ`ライド
		pendings.clear();
		super.clear();
	}

	function timerCallback()
	{
		// 次の要素を得る
		nextTimerTick = timer.interval + System.getTickCount();
		var obj;
		try
		{
			if(inProcessing)
			{
				// 再入
				reentered = true;
				timer.interval = 0;
				return;
			}
			inProcessing = true;
			for(;;)
			{
				if(pendings.count > 0)
				{
					// 後回しにされたタグがある龊
					obj = pendings[0];
					pendings.erase(0);
				}
				else
				{
					// 後回しにされたタグがないので次のタグを得る
					obj = getNextTag(); // 次のタグを得る

					// getNextTag() の中で、pendings に追加された (iscript など)
					if(pendings.count > 0)
					{
						pendings.add(obj);
						continue;
					}
				}

				if(obj === void)
				{
					// シナリオK了
					timer.enabled = false;
					timerEnabled =false;
					onStop();
					inProcessing = false;
					reentered = false;
					return;
				}
				else
				{
					// onTag を呼ぶ
					var step = onTag(obj);
					if(step === void)
						throw new Exception("onTag 返回了 void (" + obj.tagname + ")"
							"( 可能是标记处理器忘记返回值了 )");
					step = int step; // step を数に
					if(step == 0)
					{
						// ウェイトを欷堡氦舜韦
						timer.interval = 0;
						continue;
					}
					else if(step < 0)
					{
						switch(step)
						{
						case -5: // いったんイベントをI理(F在のタグは後回し)
							pendings.insert(0, obj);
							oneshot.mode = atmAtIdle;
							oneshot.trigger(); // トリガ
							timer.interval = 0; // タイマは停止
							inProcessing = false;
							reentered = false;
							return;
						case -4: // いったんイベントをI理
							oneshot.mode = atmAtIdle;
							oneshot.trigger(); // トリガ
							timer.interval = 0; // タイマは停止
							inProcessing = false;
							reentered = false;
							return;
						case -3: // 後回ししてブレ`ク
							pendings.insert(0, obj);
							timer.interval = 0; // タイマは停止
							inProcessing = false;
							reentered = false;
							return;
						case -2: // ブレ`ク
							timer.interval = 0; // タイマは停止
							inProcessing = false;
							reentered = false;
							return;
						case -1: // シナリオK了
							timer.interval = 0; 
							timer.enabled = false;
							timerEnabled = false;
							onStop();
							inProcessing = false;
							reentered = false;
							return;
						}
					}
					else
					{
						// 次へ
						if(timer.interval != step)
						{
							timer.interval = step;
							nextTimerTick = step + System.getTickCount();
						}
						inProcessing = false;
						reentered = false;
						return;
					}
				}
			}
			inProcessing = false;
			reentered = false;
		}
		catch(e)
		{
            //			Debug.logAsError();
			timer.enabled = false;
			timerEnabled =false;
			onStop();
			inProcessing = false;

            if (e.message.substring(0,17) == "因为剧本文件有了变化") {

                System.inform("由于剧本文件的更改，这个存档数据无法读取。\r\n即将返回标题画面，非常抱歉。");
                kag.goToStart();

            } else {
                var msg = "发生了错误\n"
                    "文件 : " + curStorage + "   行 : " + (curLine+1) + "\n"
                        "标记 : " + (obj === void ? "不明" : obj.tagname)
                            + " ( ← 可能显示了错误前后的标记 )\n"
                                + e.message;
                if((typeof e.trace) != "undefined") dm("trace : " + e.trace);
                dm(msg);
                throw new ConductorException(msg);
                //			System.inform(msg, "错误");
            }
		}
	}

	function onTag()
	{
		// オ`バ`ライドすること
		return -1;
	}

	function onStop()
	{
		// (シナリオの)停止rに呼ばれる。
		// stop() から呼ばれるわけではない。
		// オ`バ`ライドすること。
	}

	function startProcess(immediate = false)
	{
		// シナリオM行_始
		// immediate = false の龊悉戏峭期でg行を_始するので、
		// このメソッド内でタグハンドラが呼ばれることはない
		// 次のイベント配信のタイミングで最初のタグハンドラが呼ばれる。
		// immediate = true の龊悉稀このメソッド内で初回のタグハンドラが
		// I理されるため、呼び出し趣悉长违幞渐氓嗓g行がKわったら
		// すぐに吉里吉里に制御をす(すべてのv数からiける)ようにするべき。
		resetInterrupt();
		timer.interval = 0; // 初期インタ`バル
		timerEnabled = true;
		if(!_interrupted)
		{
			timer.enabled = true; // タイマ`_始
			if(immediate)
			{
				timerCallback();
			}
			else
			{
				oneshot.mode = atmExclusive;
					// イベントが配信されるまで他の非同期イベントをブロック
				oneshot.trigger(); // トリガ
			}
		}
	}

	function start()
	{
		// タイマ_始
		timerEnabled = true;
		timer.enabled = true;
	}

	function stop()
	{
		// タイマ停止
		timer.enabled = false;
		timerEnabled = false;
	}

	property interrupted
	{
		getter() { return _interrupted; }
		setter(x)
		{
			if(!x)
			{
				// enable
				if(timerEnabled)
				{
					timer.interval = 0;
					timer.enabled = true;
					oneshot.mode = atmExclusive;
						// イベントが配信されるまで他の非同期イベントをブロック
					oneshot.trigger(); // トリガ
				}
			}
			else
			{
				// disable
				oneshot.cancel();
				timer.enabled = false;
			}
			_interrupted = x;
		}
	}

	function assign(src)
	{
		// src の状Bをこのオブジェクトにコピ`
		var t = timer;
		var st = src.timer;
		t.enabled = false;
		t.interval = st.interval;
		nextTimerTick = src.nextTimerTick;
		if(st.enabled && st.interval != 0)
		{
			// タイマ interval の{整
			var delta = nextTimerTick - System.getTickCount();
			if(delta > 0) t.interval = delta; else t.interval = 1;
		}
		t.enabled = st.enabled;
		timerEnabled = src.timerEnabled;
		_interrupted = src._interrupted;
		if(src.pendings.count > 0)
			pendings.assignStruct(src.pendings);
		else
			pendings.clear();
		super.assign(src);
	}

	function store()
	{
		// store オ`バ`ライド
		return super.store(...);
	}

	function restore(dic)
	{
		// restore オ`バ`ライド
		super.restore(...);
		pendings.clear();
	}

	function loadScenario()
	{
		// loadScenario オ`バ`ライド
		pendings.clear();
		super.loadScenario(...);
	}

	function goToLabel()
	{
		// goToLabel オ`バ`ライド
		pendings.clear();
		super.goToLabel(...);
	}

	function enqueueTag(tag)
	{
		pendings.add(tag);
	}
}


class Conductor extends BaseConductor
{
	// Conductor - シナリオM行I理
	/*const*/ var mStop = 0; // 停止
	/*const*/ var mRun = 1; // 幼髦
	/*const*/ var mWait = 2; // 待ち

	var owner;
	var handlers;
	var status = mStop;
	var timeOutTimer;
	var waitUntil = %[];
	var lastTagName = ''; // 直前のタグ名

	function Conductor(owner, handlers)
	{
		// コンストラクタ
		super.BaseConductor();
		ignoreCR = global.ignoreCR;
		debugLevel = tkdlVerbose;
		this.owner = owner;
		this.handlers = handlers;
		timeOutTimer = new Timer(onTimeOut, '');
	}

	function finalize()
	{
		// finalize()
		invalidate timeOutTimer;
		super.finalize(...);
	}

	function run(immediate = false)
	{
		// g行の_始
		// immediate=true の龊悉稀
		// このメソッドをg行したらすぐに吉里吉里に制御をす
		// (すべてのv数からる)こと
		status = mRun;
		startProcess(immediate);
	}

	function sleep()
	{
		// g行の停止
		status = mStop;
		stop();
	}

	function wait(until)
	{
		// 待ち
		// until = trigger で用いるシグナル名とコ`ルバックv数の
		// 辞配列
		status = mWait;
		stop();
		(Dictionary.assign incontextof waitUntil)(until);
	}

	function waitWithTimeOut(until, timeout)
	{
		// 待ちを行うが、タイムアウトがある
		// タイムアウトrには 'timeout' がトリガされるので
		// ハンドラを定xすること。
		if(timeout == 0) timeout = 1; // timeout が 0 の龊悉 1 に
		status = mWait;
		stop();
		(Dictionary.assign incontextof waitUntil)(until);
		timeOutTimer.interval = timeout;
		timeOutTimer.enabled = true;
	}

	function onTimeOut()
	{
		// timeOutTimer がタイムアウトした
		timeOutTimer.enabled = false;
		trigger('timeout'); // 自分自身で timeout をトリガする
	}

	function trigger(name)
	{
        // waitUntil 内にシグナル名 name が存在すれば、g行再_、
		// 同rに waitUntil に登hされたメソッド(リスタ`トハンドラ)を呼ぶ
		// シグナル名に _arg がついたものが waitUntil 内にあれば、
		// それを引数としてハンドラに渡す
		// waitUntil はクリアされる
		if(status != mWait) return false;
		var func = waitUntil[name];
		if(func !== void)
		{
			var arg = waitUntil[name + '_arg'];
			if(arg !== void) func(arg); else func();
			(Dictionary.clear incontextof waitUntil)();
			run();
			return true;
		}
		else
		{
			return false;
		}
	}

	function onTag(elm)
	{
		// タグのI理
		var tagname = elm.tagname;
		var handler = handlers[tagname];
		if(handler !== void)
		{
			var ret = handler(elm);
			lastTagName = tagname;
			return ret;
		}
		return onUnknownTag(tagname, elm);
	}

	function onStop()
	{
		// BaseConductor.onStop オ`バ`ライド
		// 停止rに呼ばれるのでステ`タスを mStop にする
		status = mStop;
		if(owner.conductor == this) handlers.s(); // ハンドラの s (停止) を呼ぶ
	}

	function onScript(script, scriptname, lineofs)
	{
		// scirpt をg行する
		try
		{
			Scripts.exec(script, scriptname, lineofs);
		}
		catch(e)
		{
			throw new Exception(scriptname + " 中 行 " + lineofs + " 开始的"
				" iscript 中发生错误。"
				"\n( 详细请参考控制台 )\n" + e.message);
		}
		return true;
	}

	function store()
	{
		// store オ`バ`ライド
		return super.store(...);
	}

	function restore(dic)
	{
		// restore オ`バ`ライド
		super.restore(...);
		lastTagName = '';
	}

	function onScenarioLoad()
	{
		return owner.onConductorScenarioLoad(...);
	}

	function onScenarioLoaded()
	{
		return owner.onConductorScenarioLoaded(...);
	}

	function onLabel()
	{
		return owner.onConductorLabel(...);
	}

	function onJump()
	{
		return owner.onConductorJump(...);
	}

	function onCall()
	{
		return owner.onConductorCall(...);
	}

	function onReturn()
	{
		return owner.onConductorReturn(...);
	}

	function onAfterReturn()
	{
		return owner.onConductorAfterReturn(...);
	}

	function onScript()
	{
		return owner.onConductorScript(...);
	}

	function onUnknownTag()
	{
		return owner.onConductorUnknownTag(...);
	}

}



