// BGM.tjs - BGM管理
// Copyright (C)2001-2006, W.Dee and contributors  改?配布は自由です

class KAGSoundBuffer
{
	// 各 KAG 用サウンドバッファクラスに、この KAGSoundBuffer
	// クラスを@承させる

	var sbclass; // サウンドバッファのクラス
	var owner; // オ`ナ`

	var inFadeAndStop = false; // フェ`ドK了rに演奏を停止するか
    var inFadeAndPause = false; // フェ`ドK了rに演奏を一r停止するか
    var inFading = false; // フェ`ド中か
	var prevstatus = "unload"; // 直前のステ`タス

	function KAGSoundBuffer(owner, sbclass)
	{
		this.sbclass = sbclass;
		this.owner = owner;
	}

	function finalize()
	{
	}

	function fade()
	{
		// fade オ`バ`ライド
		inFading = true;
		inFadeAndStop = false;
        inFadeAndPause = false;
		sbclass.fade(...);
	}

	function stopFade()
	{
		// stopFade オ`バ`ライド
		sbclass.stopFade(...);
		inFadeAndStop = false;
        inFadeAndPause = false;
    }

	function stop()
	{
		// stop オ`バ`ライド
		sbclass.stop(...);
		inFadeAndStop = false;
		inFadeAndPause = false;
	}

	function fadeOutAndStop(time, delay = 0)
	{
		// rg time, delay でフェ`ドアウト後、演奏を停止する
		inFading = true;
		inFadeAndStop = true;
		sbclass.fade(0, time, delay);
	}

	function fadeOutAndPause(time, delay = 0)
	{
		// rg time, delay でフェ`ドアウト後、演奏を停止する
		inFading = true;
		inFadeAndPause = true;
		sbclass.fade(0, time, delay);
	}
    
	function onFadeCompleted()
	{
        // フェ`ドがK了した
		inFading = false;
		if(inFadeAndStop)
		{
			sbclass.stop(); // inFadeAndStop ならば停止
			inFadeAndStop = false;
        } else if (inFadeAndPause) {
			sbclass.paused = true; // inFadeAndPause ならば一r停止
			inFadeAndPause = false;
        }
		sbclass.onFadeCompleted(...);
		owner.onSoundBufferFadeCompleted(this);
	}

	function onStatusChanged()
	{
        sbclass.onStatusChanged(...);
		var ps = prevstatus; // prev. status
		var cs = sbclass.status; // current status
		prevstatus = cs;
		if(ps == "play" && cs == "stop")
			owner.onSoundBufferStop(this); // play => stop : 演奏が停止した
	}
}

class KAGWaveSoundBuffer extends WaveSoundBuffer, KAGSoundBuffer
{
	function KAGWaveSoundBuffer(owner)
	{
		WaveSoundBuffer(owner);
		KAGSoundBuffer(owner, global.WaveSoundBuffer);
	}

	function finalize()
	{
		global.KAGSoundBuffer.finalize(...);
		global.WaveSoundBuffer.finalize(...);
	}

    function onLabel(label) {
        owner.owner.onBGMLabel(label);
    }
}

class KAGMIDISoundBuffer extends MIDISoundBuffer, KAGSoundBuffer
{
	function KAGMIDISoundBuffer(owner)
	{
		MIDISoundBuffer(owner);
		KAGSoundBuffer(owner, global.MIDISoundBuffer);
	}

	function finalize()
	{
		global.KAGSoundBuffer.finalize(...);
		global.MIDISoundBuffer.finalize(...);
	}
}

class KAGCDDASoundBuffer extends CDDASoundBuffer, KAGSoundBuffer
{
	function KAGCDDASoundBuffer(owner)
	{
		CDDASoundBuffer(owner);
		KAGSoundBuffer(owner, global.CDDASoundBuffer);
	}

	function finalize()
	{
		global.KAGSoundBuffer.finalize(...);
		global.CDDASoundBuffer.finalize(...);
	}
}


class BGM
{
	var owner; // このオブジェクトを保持する KAGWindow クラスのオブジェクト

	var type = "Wave"; // BGM タイプ
	var cdVolume = "xxxx"; // 演奏に使用する CD の ボリュ`ムラベル
	var doubleBuffered = true; // クロスフェ`ドを行うか
	var midiInitialMessage = <% %>; // MIDI 初期化メッセ`ジ

	var buf1; // バッファ 1
	var buf2; // バッファ 2
	var currentBuffer;  // buf1 or buf2
	var looping = true; // ル`プ中かどうか
    var volume = 100000; // ボリュ`ム

	var playingStorage; // 演奏中のストレ`ジ
	var currentStorage; // かけの演奏中のストレ`ジ


	var _enabled; // 有郡どうか

	function BGM(owner)
	{
		this.owner = owner;

		(BGM_config incontextof this)();
		(BGM_config_override incontextof this)()
			if typeof global.BGM_config_override != "undefined";

		createBuffers(); // サウンドバッファを作成

		currentStorage = '';
		playingStorage = '';
		currentBuffer = buf1;
		_enabled = true;
	}

	function finalize()
	{
		invalidate buf1 if buf1 !== void;
		invalidate buf2 if buf2 !== void;
//		super.finalize(...);
	}

	function createBuffers()
	{
		// バッファを作成する
		if(type == "Wave")
		{
			buf1 = new KAGWaveSoundBuffer(this);
			buf2 = new KAGWaveSoundBuffer(this) if doubleBuffered;
		}
		else if(type == "MIDI")
		{
			buf1 = new KAGMIDISoundBuffer(this);
			buf2 = new KAGMIDISoundBuffer(this) if doubleBuffered;
		}
		else if(type == "CDDA")
		{
			buf1 = new KAGCDDASoundBuffer(this);
			if(doubleBuffered)
			{
				throw new Exception("CDDA 无法进行Crossfade。"
					"请设定doubleBuffered = false 。");
			}
		}
		buf1.looping = looping;
		buf2.looping = looping if buf2 !== void;
	}

	function freeBuffers()
	{
		// バッファを解放する
		invalidate buf1 if buf1 !== void;
		invalidate buf2 if buf2 !== void;
	}

	function changeDevice(newtype)
	{
		// デバイスの涓 
		var flags = %[];
		store(flags); // いったん状Bを保存
		freeBuffers(); // バッファの解放
		type = newtype;
		createBuffers(); // バッファの作成
		restore(flags); // 状Bを
	}

	function playBuffer(buf, storage, loop, paused = false, start)
	{
		// buf にして演奏を_始させる

		// 子やドライブ文字が省略された龊稀仕鳏蛐肖
		var found = true;
		if(type == "CDDA")
		{
			if(storage[1] != ':')
			{
				var drive = Storages.searchCD(cdVolume);
				if(drive == '')
				{
					// 使用可能な CD がつからない
					dm("ボリュ`ムラベル " + cdVolume + " を持った CD がドライブに入っていません");
					return; //------
				}
				else
				{
					storage = drive + ':' + storage;
				}
			}
		}
		else if(type == "Wave")
		{
			var test;
			if(!Storages.isExistentStorage(storage))
			{
				if(test = storage + ".wav", Storages.isExistentStorage(test))
					storage = test;
				else if(test = storage + ".ogg", Storages.isExistentStorage(test))
					storage = test;
				else if(test = storage + ".tcw", Storages.isExistentStorage(test))
					storage = test;
				else if(test = storage + ".mp3", Storages.isExistentStorage(test))
					storage = test;
				else
					found = false;
			}
		}
		else if(type == "MIDI")
		{
			var test;
			if(!Storages.isExistentStorage(storage))
			{
				if(test = storage + ".mid", Storages.isExistentStorage(test))
					storage = test;
				else if(test = storage + ".smf", Storages.isExistentStorage(test))
					storage = test;
				else if(test = storage + ".mdi", Storages.isExistentStorage(test))
					storage = test;
				else
					found = false;
			}

			if(midiInitialMessage.length)
				MIDISoundBuffer.midiOut(midiInitialMessage); // 初期化メッセ`ジなど
		}

		if(_enabled)
		{
			if(!found)
			{
				dm("BGM " + storage + " 无法找到");
				return;
			}

			try
			{
				buf.looping = loop; // 引数の "loop"
				buf.open(storage);
                // ごう追加 再生位置制御
                if (start !== void &&
                    buf.labels !== void &&
                    (start = buf.labels[start]) !== void &&
                    (start = start.samplePosition) !== void) {
                    buf.samplePosition = start;
                }
                buf.paused = paused;
                buf.play();
			}
			catch(e)
			{
				dm("BGM " + storage +" 无法播放 : " + e.message);
				return;
			}
		}
		currentBuffer = buf;
	}

	function play(elm)
	{
		// elm.storage で与えられた BGM の演奏を_始
		// elm.loop が true ならばル`プ再生を行う
		// elm.paused が true ならばポ`ズされた状Bで演奏を_始する
		// buf1 で演奏を行う
		var loop = elm.loop === void ? true : +elm.loop;

		try
		{
			buf1.stop();
			buf2.stop() if buf2 !== void;
		}
		catch(e)
		{
			dm("BGM の停止に失・筏蓼筏(g行はA行できます) : " + e.message);
		}
		stopFade(); // フェ`ディングはK了
        buf1.volume = volume;
        playBuffer(buf1, elm.storage, loop, elm.paused ? true : false, elm.start);
		if(loop)
			currentStorage = elm.storage; // ル`プ演奏の龊
		else
			currentStorage = ""; // gk演奏の龊
		playingStorage = elm.storage;
		looping = loop;
	}

	function fadeIn(elm)
	{
        // 音量 0 から演奏を_始し、フェ`ドインする
		var loop = elm.loop === void ? true : +elm.loop;
		var time = elm.time === void ? 5000 : +elm.time;

//		stopFade();
		try
		{
			buf1.stop();
			buf2.stop() if buf2 !== void;
		}
		catch(e)
		{
			dm("BGM の停止に失・筏蓼筏(g行はA行できます) : " + e.message);
		}
		if(time != 0) buf1.volume = 0; else buf1.volume = volume;
		playBuffer(buf1, elm.storage, loop, false, elm.start);
		if(_enabled) if(time !=0 ) currentBuffer.fade(volume, time);
		looping = loop;
		if(loop) currentStorage = elm.storage; else currentStorage = "";
		playingStorage = elm.storage;
	}

	function stop()
	{
		// 演奏を停止
		try
		{
			buf1.stop();
			buf2.stop() if buf2 !== void;
		}
		catch(e)
		{
			dm("BGM の停止に失・筏蓼筏(g行はA行できます) : " + e.message);
		}
//		stopFade();
        currentStorage = "";
		playingStorage = "";
	}

	function pause()
	{
		// 演奏を一r停止
		buf1.paused = true;
		buf2.paused = true if buf2 !== void;
	}

	function resume()
	{
        // 演奏を再_
        buf1.paused = false;
        buf2.paused = false if buf2 !== void;
	}

	function fadeOut(elm)
	{
		// フェ`ドアウト
//		stopFade();
		if(_enabled) currentBuffer.fadeOutAndStop(elm.time);
		currentStorage = "";
	}

    function fadePause(elm)
    {
        if(_enabled) currentBuffer.fadeOutAndPause(elm.time);
    }    
    
	function fade(elm)
	{
		// 指定音量までフェ`ド
		var time = elm.time === void ? 5000 : +elm.time;
		var vol = +elm.volume * 1000;
//		stopFade();
		if(_enabled)
		{
			currentBuffer.fade(vol, time);
		}
		volume = vol;
	}

	function stopFade()
	{
		buf1.stopFade();
		buf2.stopFade() if buf2 !== void;
	}

	function exchange(elm)
	{
		// 曲を入れ替える
		// F在演奏中の曲は time で指定されたrgをかけてフェ`ドアウトされ、
		// storage で指定された曲が time で指定されたrgをかけてフェ`ドイン
		// 再生される。
		// time が指定されていなくて、intime と outtime が指定されている龊悉稀
		// intime でフェ`ドインrg、outime でフェ`ドアウトrgを指定したこと
		// になる。
		// overlap には、F在演奏中の曲がフェ`ドアウトされてから新しい曲が
		// フェ`ドインされるまでの待ちrg(ただし与えるの正は逆)で、
		// 正のを指定するとクロスフェ`ドになる。
		// storage は、このメソッドが呼ばれたr点で演奏を_始する

		if(elm.storage == playingStorage) return;

//		stopFade();

		var loop = elm.loop === void ? true : +elm.loop;
		var intime, outtime;
		if(elm.time === void)
		{
			intime = elm.intime === void ? 5000:+elm.intime;
			outtime = elm.outtime === void ? 5000:+elm.outtime;
		}
		else
		{
			intime = outtime = elm.time === void ? 5000 : +elm.time;
		}
		var overlap = elm.overlap === void ? 0 : +elm.overlap;

		if(!_enabled)
		{
			// o郡摔胜盲皮い龊悉 一 play を呼んでからそのまま返る
			play(elm);
			return;
		}

		if(playingStorage == '')
		{
			// F在演奏中の曲がない龊悉稀gなるフェ`ドインと同じ幼鳏摔胜
			elm.time = intime;
			fadeIn(elm);
			return;
		}

		volume = int(+elm.volume * 1000) if elm.volume !== void;

		if(doubleBuffered)
		{
			// ダブルバッファリングの龊
			if(outtime != 0)
				currentBuffer.fadeOutAndStop(outtime); // F在演奏中の BGM をフェ`ドアウト
			else
				currentBuffer.stop();
			var nextbuffer; // 次の演奏バッファ
			nextbuffer = (currentBuffer == buf1) ? buf2 : buf1;
			if(intime != 0) nextbuffer.volume = 0; else nextbuffer.volume = volume;
			playBuffer(nextbuffer, elm.storage, loop, false, elm.start);
			if(intime != 0) nextbuffer.fade(volume, intime, outtime - overlap);
		}
		else
		{
			// シングルバッファリングの龊
			play(elm); // gに次の曲を演奏するだけ
		}

		if(loop)
			currentStorage = elm.storage;
		else
			currentStorage = "";
		looping = loop;
		playingStorage = elm.storage;

	}

	function setVolume(vol)
	{
		volume = +vol;
		stopFade();
		buf1.volume = volume;
		buf2.volume = volume if doubleBuffered;
	}

	function setOptions(elm)
	{
		if(elm.device !== void)
		{
			changeDevice(elm.device);
		}
		if(elm.volume !== void)
		{
			setVolume(int(+elm.volume * 1000));
		}
		if(elm.gvolume !== void)
		{
			// 大域ボリュ`ム
			var sysvar = owner.scflags; // システム(コア)涫
			if(sysvar.bgm === void) sysvar.bgm = %[];
            sysvar = sysvar.bgm;
            var v2 = +elm.gvolume;
            v2 = int(v2 * 1000);
			sysvar.globalVolume = v2;
            if (sysvar.enable === void || sysvar.enable) {
                buf1.volume2 = v2;
                buf2.volume2 = v2 if doubleBuffered;
            } else {
                buf1.volume2 = 0;
                buf2.volume2 = 0 if doubleBuffered;
            }
		}
	}

	property inFading // フェ`ド中かどうかを返す
	{
		getter { return  currentBuffer.inFading; }
	}

	property canWaitStop // BGM のK了を待てるかどうかを返す
	{
		getter { return currentBuffer.status == "play" && !currentBuffer.looping; }
	}


	function onSoundBufferFadeCompleted(source)
	{
		if(currentBuffer == source)
		{
			// フェ`ドがK了した
			owner.onBGMFadeCompleted();
		}
	}

	function onSoundBufferStop(source)
	{
        if(currentBuffer == source)
		{
			// 演奏がK了した
			playingStorage = "";
			currentStorage = "";
			owner.onBGMStop();
		}
	}

	function store()
	{
		// 辞配列にF在の状Bを待避
		var dic = %[];
		dic.currentStorage = currentStorage;
        dic.paused = buf1.paused;
		dic.volume = volume;
		return dic;
	}

	function restore(dic)
	{
		// 辞配列からF在の状Bを
		stopFade();
        setVolume(dic.volume);
        if(dic.currentStorage != "") {
            play(%[ storage : dic.currentStorage, loop : true, paused: dic.paused]);
        } else
			stop();
	}

	function restoreSystemState(dic)
	{
		// システム涫 dic から情螭蛟O定する
		// 大域ボリュ`ムの情螭虻盲
        var sysvar = dic.bgm;
        if(sysvar !== void)
		{
            if (sysvar.enable === void || sysvar.enable) {
                var v2 = sysvar.globalVolume;
                if(v2 !== void)	{
                    v2 = +v2;
                    buf1.volume2 = v2;
                    buf2.volume2 = v2 if doubleBuffered;
                }
            } else {
                buf1.volume2 = 0;
                buf2.volume2 = 0 if doubleBuffered;
            }
		}
	}


    // true の龊悉膝堀辚濠`ムa正する
    var _voldown;

    property voldown {
        getter() {
            return _voldown;
        }
        setter(v) {
            _voldown = v;
            if (_enabled &&  currentStorage != "") {
                if (_voldown) {
                    currentBuffer.fade(volume * 0.5, 300);
                } else {
                    currentBuffer.fade(volume, 300);
                }
            }
        }
    }

    function setLoop(loop) {
        if(_enabled) {
            currentBuffer.looping = loop;
            // ル`プするときはフラグ0を0にしておくル`ルに!
            currentBuffer.flags[0] = loop ? 0 : 1;
        }
        looping = loop;
    }

}


