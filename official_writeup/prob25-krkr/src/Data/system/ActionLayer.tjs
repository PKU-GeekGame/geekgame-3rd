var ACTION_MODULE_NUM = 6;

/**
 * アクションC能をしたレイヤ
 */
class ActionLayer extends AffineLayer {

    var _modules;  ///< モジュ`ル保持用配列
    var _actionTimer;    ///< アクションl佑氓骏ぅ

    /**
     * コンストラクタ
     */
    function ActionLayer(win,par=null) {
        super.AffineLayer(win,par);
        _modules = new Array();
        _actionTimer = new Timer(actionHandler, '');
        _actionTimer.capacity = 1;
        _actionTimer.interval = 10;
        _actionTimer.enabled  = false;
    }

    /**
     * ファイナライザ
     */
    function finalize() {
        stopAction();
        invalidate _actionTimer;
        invalidate _modules;
        super.finalize();
    }

    /**
     * 画像のコピ`(LayerのC能をオ`バライド)
     * @param src コピ`元のレイヤ
     */
    function assignImages(src) {
        stopAction();
        super.assignImages(src);
        if (src instanceof "ActionLayer") {
            _modules = new Array();
            for (var i=0;i<ACTION_MODULE_NUM; i++) {
                if (src._modules[i] != void) {
                    _modules[i] = src._modules[i];
                }
            }
            _beginAction();
        }
    }

    
    /**
     * 初期化I理
     */
    function reset() {
        stopAction();
        super.reset();
    }

    /**
     * アクションをスキップするかどうかの指定
     * 胜扦膝攻ップしない。m宜@承すること。
     */
    function isSkip() {
        return false;
    }

    // アクションを中止する
    function stopAction() {
        actionHandler(true);
    }
    
    /**
     * アクションI理用
     * @param stopFlag 制停止指令
     */
    function actionHandler(stopFlag) {
        var now = System.getTickCount();
        var done = true;
        for (var i=0;i<ACTION_MODULE_NUM; i++) {
            if (_modules[i] != void) {
                if (_modules[i].run(this, now, isSkip(), stopFlag == true)) {
                    _modules[i] = void;
                } else {
                    done = false;
                }
            }
        }
        if (done) {
            if (_actionTimer.enabled) {
                _actionTimer.enabled = false;
                invalidate _modules;
                _modules = new Array();
                onActionCompleted();
            }
        }
    }

    function _beginAction() {
        // アクションが存在してれば_始する
        if (!_actionTimer.enabled) {
            for (var i=0;i<ACTION_MODULE_NUM; i++) {
                if (_modules[i] != void) {
                    _actionTimer.enabled = true;
                    break;
                }
            }
        }
    }

    
    /**
     * アクションを_始する
     * }数回呼び出し可能。モジュ`ルの type がなるものは同rにm用可能
     * @param moduleTyep モジュ`ルNe。LayerModule クラスの子クラスのクラスオブジェクトを指定する
     * @param options パラメ`タB想配列
     */
    function beginAction(moduleType, options=void) {
        if (moduleType == void) {
            // ignore
        } else if (typeof moduleType == "Object" && moduleType.LayerModule != void) {
            // モジュ`ルの生成と登h
            var module = new moduleType(this, options);
            _modules[module.type] = module;
        } else if (moduleType instanceof "Dictionary") {
            options = moduleType;
            var moduleName = options["module"];
            var moduleType;
            if (typeof moduleName == "String") {
                moduleType = global[moduleName];
            } else {
                moduleType = moduleName;
            }
            if (typeof moduleType == "Object" && moduleType.LayerModule != void) {
                // モジュ`ルの生成と登h
                var module = new moduleType(this, options);
                _modules[module.type] = module;
            } else {
                throw new Exception("指定的模块" + moduleName + "不存在或者不是 LayerModule ");
            }

        } else {
            throw new Exception("需要传递 LayerModule 的派生类");
        }
        _beginAction();
    }

    /**
     * アクションK了rに呼び出されるイベント
     */
    function onActionCompleted() {
    }

    /**
     * アクションg行中か
     */
    property inAction {
        getter() {
            return _actionTimer.enabled;
        }
    }
    
    // --------------------------------------------
    // コンビニエントメソッド
    // --------------------------------------------

    /**
     * 不透明度を指定する
     * @param opacity 不透明度
     * @time 涓にかかるrg
     */
    function setOpacityTime(o, time) {
        if (time) {
            beginAction(LayerFadeToModeModule, %["opacity" => o, "time" => time]);
        } else {
            opacity = o;
        }
    }

    /**
     * 回量を指定する
     * @param r 回量
     * @time 涓にかかるrg
     */
    function setRotateTime(r, time) {
        if (time) {
            beginAction(LayerToRotateModule, %["angle" => r, "time" => time]);
        } else {
            rotate = r;
        }
    }
    
    /**
     * ズ`ム量を指定する
     * @param zoom 回量
     * @time 涓にかかるrg
     */
    function setZoomTime(z, time) {
        if (time) {
            beginAction(LayerNormalZoomModule, %["zoom" => z, "time" => time]);
        } else {
            zoom = z;
        }
    }

    /**
     * 自右婴蛑付à工
     * @param x X位置
     * @param y Y位置
     * @param accele :p速 0:形 正:加速
     * @time 涓にかかるrg
     */
    function setMove(x, y, accel, time) {
        if (time) {
            var elm = %[ "x" => x, "y" => y, "time" => time];
            if (accel > 0) {
                beginAction(LayerAccelMoveModule, elm);
            } else if (accel == 0) {
                beginAction(LayerNormalMoveModule, elm);
            } else {
                beginAction(LayerDecelMoveModule, elm);
            }
        } else {
            // 他のアクションを停止
            _modules[0] = void;
            setPos(x, y);
        }
    }
    
};

/**
 * レイヤアクションモジュ`ル基底クラス
 */
class LayerModule {

    var type;   /// アクションNe
    var first;  
    var startTime;
    var time;   // I理rg
    var delay;  // _始W延
    var options;

    /**
     * コンストラクタ
     * @param layer レイヤ
     * @param params パラメ`タ
     */
    function LayerModule(layer, options) {
        this.options = options;
        delay = (int)options.delay if options.delay;
        time  = (int)options.time if options.time;
        first = true;
        startTime = 0;
    }

    /**
     * I理g行
     * @param now F在r刻(tick)
     * @param skip スキップ指定
     */
    function run(layer, now, skip, stop) {
        if (first) {
            startTime = now;
            first = false;
        }
        now -= startTime;
        if (delay) {
            now -= delay;
            if (now < 0) {
                return;
            }
        }
        var done = false;
        if (time) {
            if (now >= time || skip || stop) {
                done = true;
                now = time;
            }
        }
        if (stop) {
            done = true;
        }
        return action(layer, now, done) == true || done;
    }

    /**
     * I理g行（eg装)
     * @param layer 象レイヤ
     * @param now F在r刻(tick)
     * @param done K了指定
     * @return K了する龊悉 true を返す
     */
    function action(layer, now, done) {
        return true;
    }
};

// -------------------------------------------------------------------------

/**
 * 移鹰猊弗濠`ル
 * パラメ`タ: x 移酉任恢
 * パラメ`タ: y 移酉任恢
 */
class LayerMoveModule extends LayerModule {
    var start_x;
    var start_y;
    var diff_x;
    var diff_y;
    function LayerMoveModule(layer, options) {
        super.LayerModule(layer, options);
        type = 0;
        start_x = layer.left;
        start_y = layer.top;
        diff_x  = (int)options["x"] - start_x;
        diff_y  = (int)options["y"] - start_y;
    }
}

/**
 * 形移
 */
class LayerNormalMoveModule extends LayerMoveModule {
    function LayerNormalMoveModule(layer, options) {
        super.LayerMoveModule(layer, options);
    }
    function action(layer, now, done) {
        if (time) {
            layer.setPos(start_x + diff_x * now / time,
                              start_y + diff_y * now / time);
        } else {
            layer.setPos(start_x + diff_x, start_y + diff_y);
            return true;
        }
    }
};

/**
 * 加速移
 */
class LayerAccelMoveModule extends LayerMoveModule {
    function LayerAccelMoveModule(layer, options) {
        super.LayerMoveModule(layer, options);
    }
    function action(layer, now, done) {
        if (time) {
            var t = now/time;
            var n = t*t;
            layer.setPos(start_x + diff_x*n, start_y + diff_y*n);
        } else {
            layer.setPos(start_x + diff_x, start_y + diff_y);
            return true;
        }
    }
};

/**
 * p速移
 */
class LayerDecelMoveModule extends LayerMoveModule {
    function LayerDecelMoveModule(layer, options) {
        super.LayerMoveModule(layer, options);
    }
    function action(layer, now, done) {
        if (time) {
            var t = now/time;
            var n = ( 1-(1-t)*(1-t) );
            layer.setPos(start_x + diff_x*n, start_y + diff_y*n);
        } else {
            layer.setPos(start_x + diff_x, start_y + diff_y);
            return true;
        }
    }
};

/**
 * 放物移
 * x/y: 放物点（最K点ではないことに注意）
 * topTime: 点通^rg（trgの1/2を指定すると丁度落下しきる 途中で止めたい龊悉暇trgと{整）
 */
class LayerParabolaMoveModule extends LayerMoveModule {
    var t0;    // 点通^rg（の2倍）
    function LayerParabolaMoveModule(layer, options) {
        super.LayerMoveModule(layer, options);
        var topTime = (int)options["toptime"];
        t0 = topTime ? (topTime * 2) : time;
    }
    function action(layer, now, done) {
        if ( t0 ) {
            // XSは等速移印YSは2次v数移
            var t = now*2/t0;
            // 原点と(1,1)を通り、逆U字型のカ`ブを描く2次v数
            var n = ( 1-(1-t)*(1-t) );
            layer.setPos(start_x + diff_x*t, start_y + diff_y*n);
        } else {
            // rg指定の省略は不可だが、一曷湎陇筏郡猡韦趣撙胜筏XSだけ移婴工
            layer.setPos(start_x + diff_x, start_y);
            return true;
        }
    }
};

// -------------------------------------------------------------------------

/**
 * アクションモジュ`ル
 */
class LayerActionModule extends LayerModule {
    function LayerActionModule(layer, options) {
        super.LayerModule(layer, options);
        type = 1;
    }
};

/**
 * 振鹰クション
 * vibration 振恿(pixel)
 * waitTime 振娱gの待ちrg(ms)
 */
class LayerVibrateActionModule extends LayerActionModule {
    var vibration;
    var waitTime;
    var nextTime;
    function LayerVibrateActionModule(layer, options) {
        super.LayerActionModule(layer, options);
        vibration  = (int)options["vibration"];
        waitTime   = (int)options["waittime"];
        nextTime = 0;
    }
    function action(layer, now, done) {
        if (done) {
            layer.setActionOffset(0, 0);
        } else if (now >= nextTime) {
            layer.setActionOffset(Math.random() * vibration - vibration/2,
                                  Math.random() * vibration - vibration/2);
            if (waitTime) {
                nextTime += waitTime;
            }
        }
    }
};

/**
 * kゆれアクション
 * vibration 上下振恿(pixel)
 * cycle 周期(ms)
 */
class LayerJumpActionModule extends LayerActionModule {
    var vibration;
    var cycle;
    function LayerJumpActionModule(layer, options) {
        super.LayerActionModule(layer, options);
        vibration = (int)options["vibration"];
        cycle     = (int)options["cycle"];
    }
    function action(layer, now, done) {
        if (done) {
            layer.setActionOffset(0, 0);
        } else {
            layer.setActionOffset(0, vibration * Math.sin(Math.PI * 2 * now / cycle));
        }
    }
};

/**
 * kゆれアクション(gk)
 * vibration 上下振恿(pixel)
 * cycle 周期(ms)
 */
class LayerJumpOnceActionModule extends LayerActionModule {
    var vibration;
    var cycle;
    function LayerJumpOnceActionModule(layer, options) {
        super.LayerActionModule(layer, options);
        vibration = (int)options["vibration"];
        cycle     = (int)options["cycle"];
    }
    function action(layer, now, done) {
        if (now >= cycle/2) {
            done = true;
        }
        if (done) {
            layer.setActionOffset(0, 0);
        } else {
            layer.setActionOffset(0, vibration * Math.sin(Math.PI + Math.PI * 2 * now / cycle));
        }
    }
};

/**
 * 横ゆれアクション
 * vibration 左右振恿(pixel)
 * cycle 周期(ms)
 */
class LayerWaveActionModule extends LayerActionModule {
    var vibration;
    var cycle;
    function LayerWaveActionModule(layer, options) {
        super.LayerActionModule(layer, options);
        vibration = (int)options["vibration"];
        cycle     = (int)options["cycle"];
    }
    function action(layer, now, done) {
        if (done) {
            layer.setActionOffset(0, 0);
        } else {
            layer.setActionOffset(vibration * Math.sin(Math.PI * 2 * now / cycle), 0);
        }
    }
};

/**
 * 横ゆれアクション(gk)
 * vibration 上下振恿(pixel)
 * cycle 周期(ms)
 */
class LayerWaveOnceActionModule extends LayerActionModule {
    var vibration;
    var cycle;
    function LayerWaveOnceActionModule(layer, options) {
        super.LayerActionModule(layer, options);
        vibration = (int)options["vibration"];
        cycle     = (int)options["cycle"];
    }
    function action(layer, now, done) {
        if (now >= cycle/2) {
            done = true;
        }
        if (done) {
            layer.setActionOffset(0, 0);
        } else {
            layer.setActionOffset(vibration * Math.sin(Math.PI + Math.PI * 2 * now / cycle), 0);
        }
    }
};

/**
 * 落下アクション
 * distance 落下距x
 * fallTime 落下rg
 */
class LayerFallActionModule extends LayerActionModule {
    var distance;
    var fallTime;
    function LayerFallActionModule(layer, options) {
        super.LayerActionModule(layer, options);
        distance = (int)options["distance"];
        fallTime = (int)options["falltime"];
        if (fallTime == void) {
            fallTime = time;
        }
    }
    function action(layer, now, done) {
        if (now >= fallTime) {
            done = true;
        }
        if (done) {
            layer.setActionOffset(0, 0);
        } else {
            layer.setActionOffset(0, - distance + distance * now / fallTime);
        }
        return done;
    }
};

// -------------------------------------------------------------------------

/**
 * 大s小モジュ`ル
 */
class LayerZoomModule extends LayerModule {
    var startZoomX;
    var startZoomY;
    function LayerZoomModule(layer, options) {
        super.LayerModule(layer, options);
        type = 3;
        startZoomX = layer.zoomx;
        startZoomY = layer.zoomy;
    }
};

/**
 * g大
 * zoom: 最Kサイズ（kL?横Lになっている状Bからの涓は考]しない）
 */
class LayerNormalZoomModule extends LayerZoomModule {
    var zoom;
    var diff;
    function LayerNormalZoomModule(layer, options) {
        super.LayerZoomModule(layer, options);
        zoom = (int)options["zoom"];
        diff = zoom - startZoomX;
    }
    function action(layer, now, done) {
        if (time) {
            var t = now/time;
            // 大rは加速、s小rはp速
            var n = (diff<0)?( 1-(1-t)*(1-t) ):( t*t );
            layer.zoom = startZoomX + diff*n;
        } else {
            layer.zoom = zoom;
            return true;
        }
    }
};

/**
 * sを使ったM似3D回（kS）
 * angvel: 回の角速度（度/sec）
 */
class LayerVRotateZoomModule extends LayerZoomModule {
    var angvel;
    function LayerVRotateZoomModule(layer, options) {
        super.LayerZoomModule(layer, options);
        angvel = (int)options["angvel"];
    }
    function action(layer, now, done) {
        var angle = ( (angvel*now*2*Math.PI) / 360000.0/*= 360*1000*/ );
        layer.setZoom(startZoomX*Math.cos(angle), startZoomY);
    }
};

/**
 * sを使ったM似3D回（横S）
 * angvel: 回の角速度（度/sec）
 */
class LayerHRotateZoomModule extends LayerZoomModule {
    var angvel;
    function LayerHRotateZoomModule(layer, options) {
        super.LayerZoomModule(layer, options);
        angvel = (int)options["angvel"];
    }
    function action(layer, now, done) {
        var angle = ( (angvel*now*2*Math.PI) / 360000.0/*= 360*1000*/ );
        layer.setZoom(startZoomX, startZoomY*Math.cos(angle));
    }
};

/**
 * ハ`トビ`ト
 * zoom: 最大大率
 */
class LayerHeartBeatZoomModule extends LayerZoomModule {
    var diff;
    function LayerHeartBeatZoomModule(layer, options) {
        super.LayerZoomModule(layer, options);
        diff = (int)options["zoom"] - startZoomX;
    }
    function action(layer, now, done) {
        if (time) {
            var n = Math.sin( (now*Math.PI) / time );
            layer.zoom = startZoomX + diff*n;
        } else {
            return true;
        }
    }
};

/**
 * ズ`ム振
 * vibration 振恿(％)
 * waitTime 振娱gの待ちrg(ms)
 */
class LayerVibrateZoomModule extends LayerZoomModule {
    var vibration;
    var waitTime;
    var nextTime;
    function LayerVibrateZoomModule(layer, options) {
        super.LayerZoomModule(layer, options);
        vibration  = (int)options["vibration"];
        waitTime   = (int)options["waittime"];
        nextTime = 0;
    }
    function action(layer, now, done) {
        if (done) {
            layer.setZoom(startZoomX, startZoomY);
        } else {
            if (now >= nextTime) {
                layer.setZoom(
                    startZoomX + Math.random() * vibration - vibration/2,
                    startZoomY + Math.random() * vibration - vibration/2);
                if (waitTime) {
                    nextTime += waitTime;
                }
            }
        }
    }
};

// -------------------------------------------------------------------------

class LayerRotateModule extends LayerModule {
    var startRotateAngle;
    function LayerRotateModule(layer, options) {
        super.LayerModule(layer, options);
        type = 2;
        startRotateAngle = layer.rotate;
    }
};

/**
 * g回
 * angvel: 角速度（度/sec）
 */
class LayerNormalRotateModule extends LayerRotateModule {
    var angvel;
    function LayerNormalRotateModule(layer, options) {
        super.LayerRotateModule(layer, options);
        angvel = (int)options["angvel"];
    }
    function action(layer, now, done) {
        layer.rotate = (startRotateAngle + angvel * now / 1000) % 360;
    }
};

/**
 * 回振樱ㄆ黏上がりこぼし／振り子）
 * vibration: 振幅(度)
 * cycle: 周期(ms)
 */
class LayerVibrateRotateModule extends LayerRotateModule {
    var vibration;
    var cycle;;
    function LayerVibrateRotateModule(layer, options) {
        super.LayerRotateModule(layer, options);
        vibration = (int)options["vibration"];
        cycle     = (int)options["cycle"];
    }
    function action(layer, now, done) {
        layer.rotate = (startRotateAngle + (vibration * Math.sin(Math.PI * 2 * now / cycle))) % 360;
    }
};

/**
 * 倒
 * angle: 倒r最大角（-90～90がm正 正で左、で右に倒）
 */
class LayerFalldownRotateModule extends LayerRotateModule {
    var angle;
    function LayerFalldownRotateModule(layer, options) {
        super.LayerRotateModule(layer, options);
        angle = (int)options["angle"];
    }
    function action(layer, now, done) {
        if (time) {
            var a = (angle*now*now/(time*time));
            layer.rotate = (startRotateAngle + a) % 360;
        } else {
            layer.rotate = (startRotateAngle + angle) % 360;
            return true;
        }
    }
};

/**
 * 指定角度へ
 * angle: 指定角度
 */
class LayerToRotateModule extends LayerRotateModule {
    var angle;
    function LayerToRotateModule(layer, options) {
        super.LayerRotateModule(layer, options);
        angle = (int)options["angle"];
    }
    function action(layer, now, done) {
        if (time) {
            layer.rotate = startRotateAngle + (angle - startRotateAngle) * now / time;
        } else {
            layer.rotate= angle;
            return true;
        }
    }
};

// -------------------------------------------------------------------------

/**
 * モ`ドモジュ`ル
 */
class LayerModeModule extends LayerModule {
    function LayerModeModule(layer, options) {
        super.LayerModule(layer, options);
        type = 4;
    }
};

/**
 * 点I理用
 * showTime 表示rg(ms)
 * hideTime 消去rg(ms)
 */
class LayerBlinkModeModule extends LayerModeModule {
    var showFlag;
    var showTime;
    var hideTime;
    function LayerBlinkModeModule(layer, options) {
        super.LayerModeModule(layer, options);
        showFlag = true;
        showTime = (int)options["showtime"];
        hideTime = (int)options["hidetime"];
    }
    function action(layer, now, done) {
        if (done) {
            layer.visible = true;
        } else {
            if (now % (showTime + hideTime) < showTime) {
                layer.visible = true;
            } else {
                layer.visible = false;
            }
        }
    }
};

/**
 * フェ`ドI理用
 * intime  フェ`ドインrg   (0の龊膝榨З`ドインしない)
 * outtime フェ`ドアウトrg (0の龊膝榨З`ドアウトしない)
 */
class LayerFadeModeModule extends LayerModeModule {
    var opacity;
    var inTime;
    var outTime;
    function LayerFadeModeModule(layer, options) {
        super.LayerModeModule(layer, options);
        opacity = layer.opacity;
        inTime  = (int)options["intime"];
        outTime = (int)options["outtime"];
        if (outTime === void) {
            outTime = 0;
        }
        if (inTime == 0 && outTime == 0) {
            inTime = 1000; // XXX
        }
    }
    function action(layer, now, done) {
        if (done) {
            layer.opacity = opacity;
        } else {
            now = now % (inTime + outTime);
            if (now <= inTime) {
                layer.opacity = now * opacity / inTime;
            } else {
                if (outTime > 0) {
                    layer.opacity = (outTime - (now - inTime)) * opacity / outTime;
                } else {
                    layer.opacity = opacity;
                }
            }
        }
    }
};

/**
 * 指定された不透明度に涓
 * opacity 不透明度
 */
class LayerFadeToModeModule extends LayerModeModule {
    var opacity;
    var toOpacity;
    function LayerFadeToModeModule(layer, options) {
        super.LayerModeModule(layer, options);
        opacity = layer.opacity;
        toOpacity = (int)options["opacity"];
    }
    function action(layer, now, done) {
        if (time) {
            layer.opacity = opacity + (toOpacity - opacity) * now / time;
        } else {
            layer.opacity = toOpacity;
            return true;
        }
    }
};

