// GraphicLayer.tjs - グラフィック系レイヤ(背景,キャラクタ)
// Copyright (C)2001-2006, W.Dee and contributors  改?配布は自由です

class ProvinceContext
{
	// I域アクション用コンテキスト
	var target;
	var storage;
	var onenter;
	var onleave;
	var hint;
	var exp;
	var cursor;
	var countpage;
	var autodisable;

	function ProvinceContext() {};
    function finalize() {};
}

class GraphicLayer extends AnimationLayer
{
	// 背景/前景レイヤの基本クラス

	var comp; // のレイヤ
	var id; // ID
	var provinceActions = void; // クリッカブルマップのI域ごとのアクション定x
	var pointingProvince = 0; // F在指し示しているI域番号
	var loadedProvinceImage = ""; // loadImages 後にiみzまれたI域画像
	var loadedProvinceActions = ""; // loadImages 後にiみzまれたI域アクション
	var defaultCursor = crDefault; // デフォルトのカ`ソル
	var lastMouseDownX; // 最後にマウスがクリックされた X 座
	var lastMouseDownY; // 最後にマウスがクリックされた Y 座

	function GraphicLayer(win, par, name, id)
	{
		// GraphicLayer コンストラクタ
		// win    : ウィンドウオブジェクト
		// par    : Hレイヤ
		// name   : レイヤの名前
		super.AnimationLayer(win, par);

		this.name = name;
		this.id = id;
		/* のレイヤ は、このオブジェクトを作成後に setCompLayer でO定すること */
	}

	function finalize()
	{
		clearProvinceActions();
		super.finalize(...);
	}

	function setCompLayer(lay) { comp = lay; }

	function setDefaultCursor(c)
	{
		cursor = defaultCursor = c;
	}

	function loadImages(elm)
	{
		// elm に述されている内容に兢盲皮长违欹ぅ浃嘶像をiみzむ
		clearProvinceActions();
		loadedProvinceImage = "";
		super.loadImages(elm);
		if(elm !== void)
		{
			if(elm.mapimage !== void) super.loadProvinceImage(elm.mapimage); // I域画像をiむ
			if(elm.mapaction !== void)
			{
				internalLoadProvinceActions(elm.mapaction); // I域アクションをiむ
			}
			else
			{
				var name;
				var storage = Storages.getPlacedPath(
					name = (Storages.chopStorageExt(elm.storage) + ".ma")); // 子が .ma のファイル
				if(storage != '')
					loadProvinceActions(name);
			}
		}
	}

	function loadProvinceImage(fn)
	{
		// I域画像 fn をiみzむ
		super.loadProvinceImage(fn);
		loadedProvinceImage = fn;
	}

	function assignComp()
	{
		// になるレイヤの内容をコピ`
		assign(comp);
	}

	function assign(src)
	{
		super.assign(...);

		if(provinceActions !== void)
		{
			invalidate provinceActions;
			window.disableMouseKey();
		}
		if(src.provinceActions !== void)
		{
			(provinceActions = []).assign(src.provinceActions);
			window.enableMouseKey();
		}
		else
		{
			provinceActions = void;
		}
		loadedProvinceImage = src.loadedProvinceImage;
		loadedProvinceActions = src.loadedProvinceActions;
	}

	function beginTransition(elm)
	{
		// elm に兢盲匹去楗螗弗伐绁螭蛐肖
		comp.stopTransition(); // comp で行われていたトランジションも停止
		super.beginTransition(elm, comp);
	}

	function exchangeInfo()
	{
		// comp と情螭蛉・晏妞à
		// すでに 画像の内容、ツリ`造は取り浃铯盲皮い毪韦
		// 名前などを取り替える
		// また、ウィンドウの管理情螭飧新するようにする
		var src = comp;
		var tmp = src.name;
		src.name = name;
		name = tmp;
		tmp = src.cursor;
		src.cursor = cursor;
		cursor = tmp;
	}

	function clearImage(process = true)
	{
		// AnimationLayer.clearImage オ`バ`ライド
		super.clearImage(process);
		loadedProvinceImage = "";
		clearProvinceActions();
	}

	function clearProvinceActions()
	{
		if(provinceActions !== void)
		{
			invalidate provinceActions;
			provinceActions = void;
			pointingProvince = 0;
			cursor = defaultCursor;
			hint = "";
			showParentHint = true;
			window.disableMouseKey();
		}
		loadedProvinceActions = "";
	}

	function internalLoadProvinceActions(fn)
	{
		// ファイル名 fn をI域アクション定xファイルとしてiみzむ
		clearProvinceActions();

		var file = [];
		file.load(fn);
		var filelines = file.count;

		// ファイルに兢盲匹攻リプトを拥膜松成
		var body = "function { var a = provinceActions; \n";
		for(var i = 0; i<filelines; i++)
		{
			var line = file[i];
			if(line == "" || line[0] == ';') continue;
			var colon = line.indexOf(':');
			if(colon == -1) continue;
			body += "a[" + line.substring(0, colon) + "] = function { " +
				line.substring(colon + 1) + " ;};\n";
		}
		body += "}\n";

		provinceActions = [];
		(Scripts.eval(body) incontextof this) (); // body のコンパイルをしてこのコンテキスト上でg行

		window.enableMouseKey();
	}

	function loadProvinceActions(fn)
	{
		internalLoadProvinceActions(fn);
		loadedProvinceActions = fn;
	}

	function queryProvinceAction(n, checkzero = true)
	{
		// I域番号 n にvするアクションを返す
		// アクションがなにも定xされていなければ void を返す
//		dm(n, provinceActions, provinceActions[n]);
		if(provinceActions === void) return void;
		if(checkzero) { if(n == 0) return void; }
		var action = provinceActions[n];
		if(action === void) return void;
		var ar = new ProvinceContext();
		(action incontextof ar) (); // ar のコンテキスト上でアクションをg行
		if(ar.target === void && ar.storage === void && ar.onenter === void &&
			ar.onleave === void && ar.hint === void && ar.exp === void &&
			ar.cursor === void && ar.countpage === void && ar.autodisable === void)
				return void;
		return ar;
	}

	function onMouseMove(x, y)
	{
		// onMouseMove イベントハンドラ
		super.onMouseMove(...);
		if(provinceActions !== void)
		{
			var n = window.messageLayerHiding ? 0 : getProvincePixel(x - imageLeft, y - imageTop);
			if(n != pointingProvince)
			{
				// なるI域の上を婴い龊
				if(pointingProvince != 0) onProvinceLeave(pointingProvince);
				if(n != 0) onProvinceEnter(n);
				pointingProvince = n;
			}
			if(n == 0)
			{
				hint = "";
				showParentHint = true;
				cursor = defaultCursor;
			}
		}
	}

	function onMouseLeave()
	{
		// onMouseLeave イベントハンドラ
		super.onMouseLeave(...);
		if(pointingProvince != 0)
		{
			onProvinceLeave(pointingProvince);
			pointingProvince = 0;
		}
	}

	function onProvinceEnter(n)
	{
		// I域番号 n にマウスが移婴筏
		var action = queryProvinceAction(n);
		if(action !== void)
		{
			if(action.onenter !== void) Scripts.eval(action.onenter);
			if(action.hint !== void) hint = action.hint;
			if(action.cursor !== void)
				cursor = action.cursor; // カ`ソル指定の方法に注意(&はつけない)
			else
				cursor = window.cursorPointed;
		}
		else
		{
			hint = "";
			showParentHint = true;
			cursor = defaultCursor;
		}
	}

	function onProvinceLeave(n)
	{
		// I域番号 n からマウスがxれた
		var action = queryProvinceAction(n);
		if(action !== void && action.onleave !== void) Scripts.eval(action.onleave);
		hint = "";
		showParentHint = true;
	}

	function processProvince(x, y)
	{
		// x, y 位置のI域で指定されたシナリオにジャンプする
		// I理された龊悉 true, されなかった龊悉 false を返す
		var n = window.messageLayerHiding ? 0 : getProvincePixel(x - imageLeft, y - imageTop);
		var action = queryProvinceAction(n);
		if(action === void) return false;
		if(action.exp !== void) Scripts.eval(action.exp);
		if(action.storage != '' || action.target != '')
		{
			var q = queryProvinceAction(0, false);
			if(q === void || q.autodisable === void || +q.autodisable) clearProvinceActions();
			window.process(action.storage, action.target, +action.countpage);
		}
		return true;
	}

	function onMouseDown(x, y, button)
	{
		lastMouseDownX = x;
		lastMouseDownY = y;
		super.onMouseDown(...);
	}

	function store()
	{
		// 情螭虼配列にh
		var dic = super.store();
		dic.loadedProvinceImage = loadedProvinceImage;
		dic.loadedProvinceActions = loadedProvinceActions;
        return dic;
	}

	function restore(dic)
	{
		// dic から情螭蛘iみ出す
		super.restore(dic);
		if(dic.loadedProvinceImage !== void && dic.loadedProvinceImage !== '')
			loadProvinceImage(dic.loadedProvinceImage);
		else
			loadedProvinceImage = "";
		if(dic.loadedProvinceActions !== void && dic.loadedProvinceActions !== '')
			loadProvinceActions(dic.loadedProvinceActions);
		else
			clearProvinceActions();
    }

}

class BaseLayer extends GraphicLayer
{
	// 背景レイヤ

	function BaseLayer(win, par, name, id)
	{
		super.GraphicLayer(win, par, name, id);
		type = ltCoverRect;
		hitType = htMask;
		hitThreshold = 0;
	}

	function finalize()
	{
		super.finalize(...);
	}

	function assign(src)
	{
		// assign オ`バ`ライド
		super.assign(src);
		// Hクラスの assign は可?不可などをコピ`しないが、
		// 背景レイヤなのでそれでよい
	}

	function loadImages(elm)
	{
		// loadImages オ`バ`ライド
		if(elm !== void)
		{
			elm.mode = "opaque"; // レイヤモ`ドを浃à椁欷毪壤Г毪韦
			delete elm.index; // インデックスを浃à椁欷毪壤Г毪韦

			if(elm.visible !== void)
			{
				// visible の状Bを浃à椁欷毪壤Г毪韦
				if(isPrimary) elm.visible = true; else elm.visible = false;
			}
		}
		super.loadImages(elm);
	}

	function restore(dic)
	{
		// restore オ`バ`ライド
		if(isPrimary) dic.visible = true; else dic.visible = false;
		dic.absolute = 0;
		super.restore(dic);
	}

	function setOptions(elm)
	{
        // setOptions オ`バ`ライド
		if(elm.visible !== void)
		{
			if(isPrimary) elm.visible = true; else elm.visible = false;
		}
		super.setOptions(elm);
	}

	function internalOnMouseDown(x, y, button, processprovince = true)
	{
		// 内部v数
		var provinceprocessed = false;
		if(button == mbLeft && processprovince && !window.messageLayerHiding)
			provinceprocessed = processProvince(x, y);
		if(button == mbLeft && !provinceprocessed)
		{
			// 自身がプライマリレイヤならば、ウィンドウの
			// onPrimaryClick を呼ぶ
			if(isPrimary) window.onPrimaryClick();
		}
		else if(button == mbRight)
		{
			// 自身がプライマリレイヤならば、ウィンドウの
			// onPrimaryRightClick を呼ぶ
			if(isPrimary) window.onPrimaryRightClick();
		}
	}

	function onMouseDown(x, y, button)
	{
		// マウスが押された
		super.onMouseDown(...);
		internalOnMouseDown(x, y, button);
	}

	function clearImage()
	{
		// GraphicLayer.clearImage オ`バ`ライド
		super.clearImage(false);
		setImageSize(window.scWidth, window.scHeight);
		setSizeToImageSize();
		face = dfAlpha;
		fillRect(0, 0, imageWidth, imageHeight, 0xff000000);
	}

	function atEndOfTransition(src, withchildren, exchange)
	{
		// atEndOfTransition オ`バ`ライド
		super.atEndOfTransition(...);
		if(src == null)
		{
			//?背景レイヤがsrcなしでトランジション(children=true)
			//　何もしなくてよいが、K了rに子レイヤは非表示になる。
			//?背景レイヤがsrcなしでトランジション(children=false)
			//　本当に何もしない。
		}
		else
		{
			if(withchildren)
			{
				//?背景レイヤがsrcありでトランジション(children=true)
				//　重要な情螭颔去楗螗弗伐绁笤と交Q、しかも子レイヤにしてもこの
				//　「重要な情螭蛳嗍证冉Q」の指示を出す。exchange=false の龊悉悉丹椁
				//　トランジション元の情螭颔去楗螗弗伐绁笙趣衰偿冤`。これも、子レイヤすべて
				//　にしても指示する。
				if(!exchange)
				{
					assign(src);
					window.callAssignTransSrc();
				}
				super.exchangeInfo();
				window.exchangeForeBack();
				window.callExchangeInfo();
			}
			else
			{
				//?背景レイヤがsrcありでトランジション(children=false)
				//　重要な情螭颔去楗螗弗伐绁笤と交Q。子レイヤにしては
				//　「重要な情螭蛳嗍证冉Q」の指示をださない。exchange=false の龊悉
				//　さらにトランジション元の情螭颔去楗螗弗伐绁笙趣衰偿冤`。
				//　これも子レイヤにしては指示しない。
				if(!exchange)
				{
					assign(src);
				}
				exchangeInfo();
			}
		}
	}

	function exchangeInfo()
	{
		// exchangeInfo オ`バ`ライド
		super.exchangeInfo();
		window.swapBaseLayer();
	}
}

class GraphicLayerEx extends GraphicLayer {
    
    function GraphicLayerEx() {
        super.GraphicLayer(...);
    }

    function setOptions(elm)
	{
        super.setOptions(elm);
        // ごう ActionLayer に
        type   = global[elm.type] if elm.type   !== void;
        rotate = +elm.rotate if elm.rotate !== void;
        zoomx  = +elm.zoomx  if elm.zoomx  !== void;
		zoomy  = +elm.zoomy  if elm.zoomy  !== void;
		zoom   = +elm.zoom   if elm.zoom   !== void;
        afx    = elm.afx    if elm.afx    !== void;
        afy    = elm.afy    if elm.afy    !== void;
        if (elm.reset !== void && elm.reset) {
            reset();
        }
	}

    /**
     * @承して。reset() させる
     */
	function freeImage() {
        super.freeImage(...);
        reset();
    }
    
    function store()
    {
		var dic = super.store();
        dic.rotate = rotate;
        dic.zoomx  = zoomx;
        dic.zoomy  = zoomy;
        dic.afx    = afx;
        dic.afy    = afy;
        return dic;
    }

	function restore(dic)
	{
		super.restore(dic);
        rotate = dic.rotate if dic.rotate !== void; 
        zoomx  = dic.zoomx  if dic.zoomx  !== void;
        zoomy  = dic.zoomy  if dic.zoomy  !== void;
        afx    = dic.afx    if dic.afx    !== void;
        afy    = dic.afy    if dic.afy    !== void;
    }

    var doAction;
    
    /**
     * アクション_始I理
     */
    function beginAction() {
        if (!inAction && !doAction) {
            window.actionCount++;
            doAction = true;
        }
        super.beginAction(...);
        //dm("アクションカウント:" + window.actionCount);
    }
    
    /**
     * アクションK了rに呼び出されるイベント
     */
    function onActionCompleted() {
        if (doAction) {
            window.actionCount--;
            doAction = false;
            //dm("动作技术:" + window.actionCount);
            if (window.actionCount <= 0) {
                window.onActionStop();
            }
            window.onLayerActionStop(this);
        }
    }
}

class StageLayer extends GraphicLayerEx
{
    // 舞台?イベント用特殊固定レイヤ

    function StageLayer(win, par, name, id)
	{
		super.GraphicLayerEx(win, par, name, id);
		type = ltCoverRect;
		hitType = htMask;
		hitThreshold = 0;
	}

	function finalize()
	{
		super.finalize(...);
	}

	function internalOnMouseDown(x, y, button, processprovince = true)
	{
		// 内部v数
		var provinceprocessed = false;
		if(button == mbLeft && processprovince && !window.messageLayerHiding)
			provinceprocessed = processProvince(x, y);
		if(button == mbLeft && !provinceprocessed)
		{
            window.onPrimaryClick();
		}
		else if(button == mbRight)
		{
            window.onPrimaryRightClick();
		}
	}

	function onMouseDown(x, y, button)
	{
		// マウスが押された
		super.onMouseDown(...);
		internalOnMouseDown(x, y, button);
	}
    
	function assign(src)
	{
		// assign オ`バ`ライド
		super.assign(src);
		assignVisibleState(src);
	}

	function atEndOfTransition(src, withchildren, exchange)
	{
		// atEndOfTransition オ`バ`ライド
		super.atEndOfTransition(...);
		if(src == null)
		{
			//?背景レイヤがsrcなしでトランジション(children=true)
			//　何もしなくてよいが、K了rに子レイヤは非表示になる。
			//?背景レイヤがsrcなしでトランジション(children=false)
			//　本当に何もしない。
		}
		else
		{
            super.assign(src);
            exchangeInfo();
            window.exchangeForeBack();
            window.callExchangeInfo();
            window.swapStageLayer(id);
		}
	}

	function assignTransSrc()
	{
		// トランジションもと(comp)をコピ`する
		assign(comp);
	}
}

class CharacterLayer extends GraphicLayerEx
{
	// 前景レイヤ
	var autoHide = false; // メッセ`ジレイヤと一wにLれることができるか
	var invisibleByUser = false; // ユ`ザにより一r的に不可
    var visibleBeforeUserInvisible  = false;
    var level; // 表示レベルa正用

	function CharacterLayer(win, par, name, id, level=0)
	{
        super.GraphicLayerEx(win, par, name, id);
		freeImage();
		type = ltCoverRect;
		hitType = htMask;
        hitThreshold = 64;
        this.level = level;
	}

	function finalize()
	{
		super.finalize(...);
	}

	function onHitTest(x, y, hit)
	{
		// onHitTest オ`バ`ライド
		if(!hit || provinceActions === void)
		{
			// hit==false またはI域アクションが定xされていない龊
			super.onHitTest(x, y, false);
		}
		else
		{
			// hit==true かつ I域アクションが定xされている龊
			super.onHitTest(x, y, !window.messageLayerHiding);
		}
		return;
	}

	function assign(src)
	{
		// assign オ`バ`ライド
		super.assign(src);
		assignVisibleState(src);
		// Hクラスの assign は可?不可などの情螭颔偿冤`しないため
		// ここで assignVisibleState を呼ぶ必要がある
        autoHide = src.autoHide;
        level = src.level;
	}

	function setOptions(elm)
	{
		// setOptions オ`バ`ライド
        super.setOptions(elm);
        autoHide = +elm.autohide if elm.autohide !== void;
	}

	function atEndOfTransition(src, withchildren, exchange)
	{
		// atEndOfTransition オ`バ`ライド
		super.atEndOfTransition(...);
		if(src == null)
		{
			//?メッセ`ジレイヤ、前景レイヤが、srcなしでトランジション (children=true)
			//　何もしなくてよいが、K了後それらの子レイヤは自拥膜朔潜硎兢摔胜搿
		}
		else
		{
			//?メッセ`ジレイヤ、前景レイヤが、srcありでトランジション (children=true)
			//　重要な情螭颔去楗螗弗伐绁笤と交Q、exchange=false の龊悉悉丹椁
			//　トランジション元の情螭颔去楗螗弗伐绁笙趣衰偿冤`。ただし、このコピ`のHに
			//　ウィンドウの可?不可の情螭膝偿冤`しない。
			super.assign(src);
			exchangeInfo();
			window.swapCharacterLayer(id);
		}
	}

	function assignTransSrc()
	{
		// トランジションもと(comp)をコピ`する
		assign(comp);
	}

	function setHiddenStateByUser(b)
	{
		// ユ`ザが右クリックなどでメッセ`ジレイヤを一r的にLすときに
		// 呼ばれる
		if(autoHide)
		{
			if(b)
			{
				visibleBeforeUserInvisible = visible;
				invisibleByUser = true; // ユ`ザにより一r的に不可
				visible = false;
			}
			else
			{
				invisibleByUser = false; // 可
				visible = visibleBeforeUserInvisible;
			}
		}
	}

	function onMouseDown(x, y, button)
	{
		// マウスが押された
		super.onMouseDown(...);
		if(button == mbLeft)
			processProvince(x, y);
		else if(button == mbRight)
			window.onPrimaryRightClick();
			// 右ボタンは window.onPrimaryRightClick() を呼ぶ
	}

	function store()
	{
		// store オ`バ`ライド
		var dic = super.store();
        dic.autoHide = autoHide;
        dic.level    = level;
        return dic;
	}

	function restore(dic)
	{
		// restore オ`バ`ライド
		autoHide = +dic.autoHide if dic.autoHide !== void;
        level    = +dic.level if dic.level !== void;
        super.restore(dic);
	}
}


