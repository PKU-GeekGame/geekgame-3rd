// AnimationLayer.tjs - アニメ`ションを行うレイヤ
// Copyright (C)2001-2006, W.Dee and contributors  改?配布は自由です


/*
-- ２つのアニメ`ションのN ---------------------------------------------

　KAGにアニメ`ションをさせるためには２つのNがあります。
　一つは「セル画像」を用いるセルを基本としたアニメ`ションで、この龊稀
「ベ`ス画像」の上に「セル画像」の各部分を切り取って次Nり付けるような感
じでアニメ`ションを行います。

　もう一つは、KAG 3.05 beta 3 から使用可能になった クリッピングを基本とした
アニメ`ション方法で、この龊悉膝互牖像は必要ありません。
　image タグに clipleft, cliptop, clipwidth, clipheight の４つの属性があり
ますが、(概念的には)これを次浃à皮浃毪长趣恰⒋螭な画像の一部分を次表
示するようなアニメ`ションを行います。表示する画像を何枚も横にKべ、それを
次表示するような用途に向いています。

　荷はクリッピングを基本としたアニメ`ション方式のほうがXいです。デモ
シ`ンにおいて、レイヤの全域をきQえるようなアニメ`ションを行う龊悉膝
リッピング方式のアニメ`ションのほうが良いでしょう。
　逆に、目パチ、口パクのような用途にはセル方式のアニメ`ションの方が小回り
が利いて使いやすいでしょう。


-- セル方式のアニメ`ションの述の仕方 -----------------------------------

　まず、アニメ`ションを行わせるためには、「ベ`ス画像」と「セル画像」が必
要になります。ベ`ス画像はアニメ`ションの下地となる画像です。セル画像はア
ニメ`ションの「部品」がKべてある画像です。ベ`ス画像の上にアニメ`ション
画像を部分的にコピ`して重ねていくという方法を用います。

　ベ`ス画像は image タグでiみzまれます (ここで用いるベ`スとは、KAGの背
景レイヤの base とは`う意味です )。セル画像は、アニメ`ション定xファイル
内の loadcell タグでiみzみます。

　アニメ`ション定xファイルは、ベ`ス画像とファイルが同じで、子が asd
のテキストファイルです。
　アニメ`ション定xファイルは KAG の文法で述しますが、タグ体系は KAG の
ものとはなります。

　アニメ`ションセグメントを用いない、gなアニメ`ションならば、KAG の
System フォルダにある LineBreak や PageBreak が参考になると思います。
　アニメ`ションセグメントを用いたサンプルはF在の所、吉里吉里ソ`スの中の
environ/win32/kag3/scenario/animtest.ks にあります。

-- セグメント -------------------------------------------------------------

　セグメントは、一Mのベ`ス画像、セル画像、asdファイルで、}数のアニメ`
ションを同rM行させるための仕Mみです。
　セグメントにはレイヤごとに 0 番から始まる番号がついています。
　セグメント 0 は特殊なセグメントでデフォルトセグメントと呼ばれ、画像のi
みzみとともにg行が自拥膜耸激蓼毳互哎幞螗趣扦埂system フォルダにある
LineBreak や PageBreak はこのデフォルトセグメントのみを使用しています。
gなアニメ`ションならばこれだけで十分だと思います。

　口パクや目パチなどを一つの画像で行いたい龊稀⒀}数のセグメントをQわなけ
ればなりません。たとえば、目パチはデフォルトセグメントで常rアニメ`ション
させておき、口パクはシナリオの制御によって_始させたり、停止させたりする、
という用途です。

　セグメントにするアニメ`ションのスタ`トは KAG の通常のシナリオの
animstart で行います。animstart は任意の ( デフォルトセグメント以外の ) セ
グメントでアニメ`ションを_始します。

　animstart タグの loop 属性が true のとき、このアニメ`ションはル`プして
いないといけません。自拥膜衰氅`プするわけではないので、ル`プするように
述しなければなりません。
　ル`プしていなくてもエラ`になるわけではありませんが、荬虮４妞筏普iみz
んだときに正しく画像が再Fされない可能性があります。
また、荬iみzまれるときは、loop=true を指定した龊悉韦撙衰ニメ`ション
が再_されますが、かならず animstart で指定したasdファイルのラベルの最初か
らg行が始まります。

　loop=false のrは、アニメ`ションはしますが、最K的に s タグで停止しなけ
ればなりません。また、[s] タグで停止したときには、ベ`ス画像と同じ状Bにっ
てなければなりません。gkのアニメ`ションを行わせたいときはこれを使います。

　animstop はアニメ`ションを停止させますが、停止を待ちません。gHはアニメ`
ションが停止するためには @home タグを通^する必要があります。

　wa は任意のセグメントのアニメ`ションのK了を待ちます。デフォルトセグメン
トのアニメ`ションもまつことができます。animstart で loop=falseを指定したと
きや、animstop でアニメ`ションを停止させたrのみ有郡扦埂Ｋの龊悉 wa を
指定した龊悉嫌肋hに待つことになってしまいます。

　荬吮４妞丹欷肭螭稀アニメ`ションがどのセグメントでどの_始ラベルから
始まったかという情螭韦撙恰どのコマ位置までMんでいるか、はhされません。
　また、ル`プ中のアニメ`ションのみが、荬蛘iみzんだときにアニメ`ション
が再_されます。


-- クリッピング方式のアニメ`ションの述の仕方 ---------------------------

　クリッピング方式でアニメ`ションを行う龊悉稀セル方式で行うときとなり、
コマ画像が横Kびになった画像を一枚用意します。
　たとえば、320x240 の画面で８枚の画像でアニメ`ションを行うならば、
2560×240 の画像を用意します ( 2560 = 320 * 8 )。
　画像をiみzむときは、最初のコマが表示されるように image タグを述します。
　たとえば、

@image storage=anim page=fore layer=0 mode=rect clipleft=0 cliptop=0 clipwidth=320 clipheight=240

　となります。
　asd ファイルには、横にKんだ各コマ画像が次表示されるように述します。
セル画像は用いないので、loadcell タグを述する必要はありません。
　たとえば、

@wait time=80
@clip left=320 top=0
@wait time=80
@clip left=640 top=0
@wait time=80
@clip left=960 top=0
@wait time=80
@clip left=1280 top=0
@wait time=80
@clip left=1600 top=0
@wait time=80
@clip left=1920 top=0
@wait time=80
@clip left=2240 top=0
@wait time=80
@s

　てお荬扭かとは思いますが、gHは横にKんでいる必要はありません。
　kにKんでいても良いですが、png などでRsするときは横Kびになっていた方
が高いRs率を得られます。

　クリッピング方式のアニメ`ションでは、荬摔稀そのレイヤがどのようにアニ
メ`ションを行っていたかの情螭保存されません。次の「荬虮４婵赡埭圣楗佶搿
を通^するまでには、そのレイヤにeの画像をiみzむなどして、クリッピング方
式のアニメ`ションの情螭o郡摔筏皮ださい。


-- asdファイル中タグのh明 ------------------------------------------------


■ loadcell

?属性

  storage (省略可)          iみzむセル画像ファイル名を指定します

?h明

　このタグはセル方式のアニメ`ションを行うときのみに使用します。
　loadcell タグはアニメ`ションのセル画像をiみzみます。セル画像をiみzま
なければアニメ`ションができないので、asd ファイルの先^には必ず述します。
storage 属性が省略された龊悉稀ベ`ス画像のファイル名に _a を付加した画像
がiみzまれます。
　asd ファイルの先^に述しさえすれば OK で、セグメントの_始ラベルの次に
述する必要はありません。


■ loop

?属性

  (なし)

?h明

　このタグはセル方式のアニメ`ションを行うときのみに使用します。
　loop タグは、デ`タがル`プを行うことを宣言するためのタグです。
　このタグを宣言したからと言って自拥膜衰签`タがル`プするわけではありませ
ん。ル`プするように述してください。
　このタグは、各セグメントでのル`プの_始を行う龊悉巍セグメントの入り口
のラベルの次あたりに述してください。最初のデフォルトセグメントの龊悉
loadcell の次あたりで OK です。

■ copy

?属性

  dx                        送先x座
  dy                        送先y座
  sx                        送元x座
  sy                        送元y座
  sw                        幅
  sh                        高さ

?h明

　このタグはセル方式のアニメ`ションを行うときのみに使用します。
　セル画像からベ`ス画像にコピ`を行います。

■ wait

?属性

  time                      待ちrg(ms)

?h明

　指定rgウェイトをとります。
　通常は、copy タグと wait タグのRり返しになります。

■ jump, if/endif, eval, iscript/endscript

　KAG のシナリオと同です。
　ただし、}数がK列してg行される物なので、涫を操作する龊悉鲜褂盲工
数が重ならないようにするなど、注意してください。

■ s

?属性

  (なし)

?h明

　通常の KAG と同じように、そこでg行を停止します。
　アニメ`ションがル`プしない龊悉稀loop タグをかずに、このタグで
停止させてください。
　画像がiみzまれたr点ではアニメ`ションをしたくないのならば、loadcell タ
グの直後に s タグをいて停止させてください。



■ home

?属性

  (なし)

?h明

　このタグはセル方式のアニメ`ションを行うときのみに使用します。
　animstop タグを指定した龊悉送Ｖ工工鏊です。これをかないと animstop
では停止できません。animstop タグを使う龊悉稀ル`プの途中に必ず一カ所以上
述してください。



■ clip

?属性

  left                      クリッピングを行う左端位置
  top                       クリッピングを行う上端位置

　このタグはクリッピング方式のアニメ`ションを行うときのみに使用します。
　image タグにおける clipleft と cliptop 属性のの抗と同じで、クリッピン
グを行う位置を指定します。
　クリッピングの幅と高さは涓できませんので、image タグで指定した幅と高さ
を浃à毪长趣悉扦ません。

*/


class AnimationConductor extends BaseConductor
{
	var owner;
	var number; // このコンダクタの番号
	var looping = false;
	var startLabel = "";
	var stopping = false; // ストップを待っている状Bか
	var running = false; // g行中か

	function AnimationConductor(owner)
	{
		super.BaseConductor(); // ス`パ`クラスのコンストラクタを呼ぶ
		ignoreCR = true; // CR はo
		debugLevel = tkdlNone;
//		debugLevel = tkdlVerbose;
		this.owner = owner;
	}

	function finalize()
	{
		owner = void; // owner への参照を切る
		super.finalize(...);
	}

	function onStop()
	{
		// g行停止
		var elm = %[];
		elm.context = this;
		owner.s(elm); // s タグを呼ぶ
	}

	function onTag(obj)
	{
		// タグがg行されるとき
		var func = owner[obj.tagname];
		if(func == void)
		{
			dm(Storages.extractFileName(curStorage) + " : 未知的标记 : " + obj.tagname);
			return 0;
		}
		obj.context = this;
		return func(obj);
	}

	function onScript(script, scriptname, lineofs)
	{
		// iscript がg行されるとき
		try
		{
			Scripts.exec(script, scriptname, lineofs);
		}
		catch(e)
		{
			throw new Exception(scriptname + " 中 行 " + lineofs + " 开始的"
				" iscript 块中发生错误。"
				"\n( 详情请参考控制台 )\n" + e.message);
		}
		return true;
	}

	function assign(src)
	{
		// src の状Bをこのオブジェクトにコピ`
		super.assign(src);
		looping = src.looping;
		startLabel = src.startLabel;
		stopping = src.stopping;
		running = src.running;
	}
}


class AnimationLayer extends ActionLayer
{
	var Anim_cellLayer; // セルレイヤ
	var Anim_segments = []; // セグメントごとのコンダクタ
	var Anim_storageName; // アニメ`ションデ`タファイル名
	var Anim_loadParams = void; // iみzみrに指定されたパラメ`タ
	var Anim_partialImageInfo = void; // 画像の部分追加iみzみのパラメ`タ
	var Anim_interrupted = false;// 中断中か

	var Anim_defaultFontInfo = %[];


	function AnimationLayer(win, par)
	{
		// AnimationLayer コンストラクタ
		super.ActionLayer(...); // ス`パ`クラスのコンストラクタを呼ぶ

		Anim_defaultFontInfo.face = font.face; // デフォルトのフォント
		Anim_defaultFontInfo.height = font.height; // デフォルトのフォントサイズ

		Anim_segments[0] = new AnimationConductor(this); // デフォルトのコンダクタ
		Anim_segments[0].number = 0;
	}

	function finalize()
	{
		clearAnim(); // アニメ`ション情螭违リア
		invalidate Anim_segments[0]; // デフォルトのコンダクタをo炕
		Anim_loadParams = void;
		Anim_partialImageInfo = void;
		super.finalize(...);
	}

	function clearImage(process = true)
	{
		// 表示を不可(不可にできれば)にし、
		// レイヤをクリアする
		// 必要に辘袱匹`バ`ライドすること
		if(process)
		{
			visible = false;
			setSize(32, 32);
			setImageSize(32, 32);
			face = dfAlpha;
			fillRect(0, 0, 32, 32, 0);
			type = ltOpaque;
			face = dfAuto;
		}
	}

	function freeImage()
	{
		// 画像を解放
		clearAnim();
		clearImage();
		Anim_loadParams = void;
		Anim_partialImageInfo = void;
	}

	function clearAnim()
	{
		// アニメ`ション情螭违リア
		// アニメ`ションセグメントのクリア
		// 各セグメント(デフォルトをのぞく)の削除
		for(var i = Anim_segments.count -1; i>=1; i--)
		{
			var seg = Anim_segments[i];
			invalidate Anim_segments[i] if seg !== void;
		}
		Anim_segments.count = 1;

		// デフォルトのセグメントの停止
		Anim_segments[0].stop();

		// アニメ`ションセルレイヤの破
		invalidate Anim_cellLayer if Anim_cellLayer !== void;
		Anim_cellLayer = void;
	}

	function loadAnimInfo(segment, label)
	{
		// アニメ`ション情螭蛑付ē互哎幞螗趣苏iみzみ、g行_始
		// segment=セグメント番号 label=_始ラベル(空文字列ならば最初から)
		// Anim_storageName に入っているファイル名のファイルをiみzむ
		if(Anim_storageName == '')
			throw new Exception(
				("对于" + Anim_loadParams !== void ? Anim_loadParams.storage : "") +
				"没有动画信息");

		var seg;
		if(Anim_segments[segment] === void)
		{
			Anim_segments[segment] = seg = new AnimationConductor(this);
			seg.number = segment;
				// 新しいセグメント用にコンダクタを作成
		}
		else
		{
			// セグメントは停止
			(seg = Anim_segments[segment]).stop();
		}

		seg.startLabel = label;
		seg.stopping = false;
		seg.running = true;
		seg.clearCallStack();
		seg.interrupted = Anim_interrupted;
		seg.loadScenario(Anim_storageName);
		if(label != '') seg.goToLabel(label);
		seg.startProcess(true);
	}

	function startAnim(elm)
	{
		// elm に兢盲匹ニメ`ションを_始する
		loadAnimInfo(+elm.seg, elm.target);
	}

	function stopAnim(segment)
	{
		// segment で行われているアニメ`ションを停止する
		var seg = Anim_segments[segment];
		if(seg === void) return; // 停止できない
		seg.stopping = true;
	}

	function canWaitAnimStop(segment)
	{
		// segment のアニメ`ションのK了を待てるかどうか
		var seg = Anim_segments[segment];
		if(seg === void) return false; // まてない
		if(!seg.running) return false; // g行中でないので待てない
		if(seg.looping && !seg.stopping) return false; // ル`プ指定されていてかつストップ待ちでないのでまてない
		return true;
	}

	function loadImages(elm)
	{
		// loadImages オ`バ`ライド
		// elm はiみzみ情
		if(elm === void)
		{
			freeImage();
			return;
		}

		Anim_loadParams = %[];
		(Dictionary.assign incontextof Anim_loadParams)(elm);
			// パラメ`タを待避

		// アニメ`ション情螭颔リア
		clearAnim();

		// 追加画像iみzみの情螭颔リア
		Anim_partialImageInfo = void;

		// 画像をiみzむ
		var taginfo = super.loadImages(elm.storage, elm.key);

		// 画像のタグ情螭颔钎榨━毳として裼
		if(taginfo)
		{
			(Dictionary.assign incontextof taginfo)(elm, false);
			elm = taginfo;
		}

		// フリップ
		var ud, lr;
		if(elm.flipud !== void && +elm.flipud)
		{
			// 上下反
			flipUD();
			ud = true;
		}
		else
		{
			ud = false;
		}

		if(elm.fliplr !== void && +elm.fliplr)
		{
			// 左右反
			flipLR();
			lr = true;
		}
		else
		{
			lr = false;
		}

		// クリッピング
		if(elm.clipleft !== void)
		{
			// クリッピングが指定されている
			width = +elm.clipwidth;
			height = +elm.clipheight;
			var cl = elm.clipleft;
			if(lr) cl = imageWidth - cl - width;
			var ct = elm.cliptop;
			if(ud) ct = imageHeight - ct - height;
			imageLeft = -cl;
			imageTop = -ct;
		}
		else
		{
			setSizeToImageSize();
		}

		// レイヤモ`ド
		{
			var mode = ltAlpha;

			if(elm.mode !== void)
			{
				var layertypeinfo = imageTagLayerType[elm.mode];
				if(layertypeinfo !== void)
					mode = layertypeinfo.type;
			}

			type = mode;
		}

		// 色a正
		face = dfAuto;
		applyColorCorrection(this, elm);

		// 可不可、位置、不透明度、インデックス
		if ( elm !== void && elm.pos !== void ) {
			// ポジションに兢盲莆恢盲Q定
			left= window.scPositionX[elm.pos] - width \ 2;
			top = window.scHeight - height;
		}
		else
		{
			if(elm.left !== void) left = +elm.left;
			if(elm.top !== void) top = +elm.top;
		}
		if(elm.visible !== void) visible = +elm.visible;
		if(elm.opacity !== void) opacity = +elm.opacity;
		absolute = +elm.index if elm.index !== void;

		// アニメ`ション情螭あれば、iみzむ
		Anim_storageName =
			Storages.getPlacedPath(
				Storages.chopStorageExt(elm.storage) + ".asd");
		if(Anim_storageName != '')
		{
			// アニメ`ション情螭あった!
			// アニメ`ション情螭颔钎榨━毳趣违偿螗昆タにiみzむ
			loadAnimInfo(0, ''); // ついでにアニメ`ション_始(もし_始できれば)
		}
	}

	function addPartialImageInfo(elm)
	{
		// elm を partialImageInfo に追加する
		// Anim_partialImageInfo に情螭蜃芳
		if(Anim_partialImageInfo === void)
			Anim_partialImageInfo = [];
		var info = %[];
		(Dictionary.assign incontextof info)(elm);
		Anim_partialImageInfo.add(info);
	}

	function loadPartialImage(elm)
	{
		// 部分追加iみzみを行う
		// このiみzみメソッドは レイヤそれ自体の
		// 色{a正、フリップなどのO定に兢
		// (兢盲 pimage タグ自体には色{a正や
		//  フリップvBの属性はない )
		// pimage タグでは、rgをずらして次部分画像をiみzみ、
		// アニメ`ションを行っていくような用途には向いていない
		// ( そのような龊悉膝ニメ`ションC能を使うべき )
		 if(elm.tagname === void) elm.tagname = "pimage";

		// カラ`キ`のQ定
		var key;
		if(elm.key !== void)
		{
			// key 指定がある
			key = elm.key;
		}
		else
		{
			// key 指定がない
			if(Anim_loadParams !== void)
				key = Anim_loadParams.key; // loadParams の方の key を使う
			else
				key = void;
		}

		// 一r使用用のレイヤを得る
		var temp = window.temporaryLayer;

		// 一rレイヤに画像をiみzむ
		var taginfo = temp.loadImages(elm.storage, key);

		// 画像のタグ情螭颔钎榨━毳として裼
		if(taginfo)
		{
			(Dictionary.assign incontextof taginfo)(elm, false);
			elm = taginfo;
		}

		// レイヤモ`ド
		{
			var mode = ltAlpha;

			if(elm.mode !== void)
			{
				var layertypeinfo = imageTagLayerType[elm.mode];
				if(layertypeinfo !== void)
					mode = layertypeinfo.type;
			}

			temp.type = mode;
		}

		// 画像a整
		var lr = false, ud = false;
		if(Anim_loadParams !== void)
		{
			// 一rレイヤにして色{a正
			applyColorCorrection(temp, Anim_loadParams);

			// フリップ
			if(Anim_loadParams.flipud !== void && +Anim_loadParams.flipud)
			{
				// 上下反
				temp.flipUD();
				ud = true;
			}

			if(Anim_loadParams.fliplr !== void && +Anim_loadParams.fliplr)
			{
				// 左右反
				temp.flipLR();
				lr = true;
			}
		}

		var dx = +elm.dx;
		var dy = +elm.dy;
		var sx = +elm.sx;
		var sy = +elm.sy;
		var sw = elm.sw === void ? temp.imageWidth : +elm.sw;
		var sh = elm.sh === void ? temp.imageHeight : +elm.sh;
		if(ud)
		{
			// 上下反
			dy = imageHeight - dy - sh;
			sy = temp.imageHeight - sy - sh;
		}
		if(lr)
		{
			// 左右反
			dx = imageWidth - dx - sw;
			sx = temp.imageWidth - sx - sw;
		}

		if(elm.mode == 'copy' || elm.mode == 'opaque')
		{
			// コピ`
			face = dfAlpha;
			copyRect(dx, dy, temp, sx, sy, sw, sh);
		}
		else
		{
			// 重ね合わせ
			var opa = elm.opacity === void ? 255 : +elm.opacity;

			switch(elm.mode)
			{
			case '': // default
			case 'pile':
			case 'alpha':
				holdAlpha = false;
				face = dfAlpha;
				break;
			case 'addalpha':
				holdAlpha = false;
				face = dfAddAlpha;
				break;
			default:
				holdAlpha = true;
				face = dfOpaque;
				break;
			}
			operateRect(dx, dy, temp, sx, sy, sw, sh, omAuto, opa);

			face = dfAuto;
		}

		// Anim_partialImageInfo に情螭蜃芳
		addPartialImageInfo(elm);

		return 0;
	}

	function drawReconstructibleText(elm)
	{
		 // (ロ`ドrに)再F可能な形式でテキストを描画する
		 // x, y = 座
		 // text = 描画する文字列
		 // face = フォント, 省略rは デフォルトフォント名
		 // size = フォントサイズ, 省略rはデフォルトフォントサイズ
		 // color = 色 (デフォルト=0xffffff)
		 // italic = 斜体かどうか (デフォルト=false)
		 // shadow = 影つきかどうか (デフォルト=true)
		 // edge = F取りかどうか (デフォルト=false)
		 // shadowcolor = 影の色 (デフォルト=0)
		 // edgecolor = F取りの色 (デフォルト=0)
		 // bold = 太字にするかどうか (デフォルト=0)
		 // vertical = kきかどうか (デフォルト=false)
		 // antialiased = アンチエイリアスするか (デフォルト=true)
		 // angle = 描画角度 (デフォルト=kきならば2700, そうでなければ0)
		 if(elm.tagname === void) elm.tagname = "ptext";

		var vertical = elm.vertical === void ? false : +elm.vertical;

		with(font)
		{
			var face = elm.face === void ? Anim_defaultFontInfo.face : elm.face;
			if(vertical) face = '@' + face;
			.face = face;
			.height = elm.size === void ? Anim_defaultFontInfo.height : +elm.size;
			.angle = elm.angle === void ? vertical ? 2700:0 : +elm.angle;
			.italic = elm.italic === void ? false : +elm.italic;
			.bold = elm.bold === void ? false: +elm.bold;
		}

		var edge = elm.edge === void ? false : +elm.edge;
		var shadow = elm.shadow === void ? true : +elm.shadow;
		var color = elm.color === void ? 0xffffff : +elm.color;
		var antialiased = elm.antialiased === void ? true : +elm.antialiased;

		face = dfAuto;

		var x = +elm.x;
		var y = +elm.y;

		if(edge)
		{
			var bcolor = elm.edgecolor === void ? 0 : +elm.edgecolor;
			drawText(x, y, elm.text, color, 255, antialiased, 512, bcolor, 1, 0, 0);
		}
		else if(shadow)
		{
			var bcolor = elm.shadowcolor === void ? 0 : +elm.shadowcolor;
			drawText(x, y, elm.text, color, 255, antialiased, 255, bcolor, 0, 2, 2);
		}
		else
		{
			drawText(x, y, elm.text, color, 255, antialiased); // 文字
		}

		// Anim_partialImageInfo に情螭蜃芳
		addPartialImageInfo(elm);

		return 0;
	}

	function applyColorCorrection(layer, param)
	{
		// layer にして色a正を行う
		var orgface = layer.face;
		var orgholdlpha = layer.holdAlpha;
		layer.face = dfAuto;
		if(param.grayscale !== void && +param.grayscale) layer.doGrayScale();
		layer.adjustGamma(
			param.rgamma, param.rfloor, param.rceil,
			param.ggamma, param.gfloor, param.gceil,
			param.bgamma, param.bfloor, param.bceil);
		if(param.mcolor !== void)
		{
			// 色重ね合わせ
			layer.face = dfOpaque;
			layer.holdAlpha = true;
			layer.colorRect(0, 0, layer.imageWidth, layer.imageHeight, +param.mcolor,
				+param.mopacity);
		}
		layer.face = orgface;
		layer.holdAlpha = orgholdlpha;
	}

	property interrupted
	{
		// すべてのセグメントに interrupted をO定する
		getter() { return Anim_interrupted; }
		setter(x)
		{
			if(Anim_interrupted != x)
			{
				for(var i = Anim_segments.count -1; i>=0; i--)
				{
					Anim_segments[i].interrupted = x;
				}
				Anim_interrupted = x;
			}
		}
	}

	function assign(src)
	{
		// レイヤの情螭颔偿冤`
		// ただし 位置、透明度、サイズ、レイヤ内画像位置はコピ`しない
		// (コピ`したい龊悉 KAGLayer.assignVisibleState を呼ぶこと)
		super.assignImages(src);

		// アニメ`ションセルレイヤのコピ`
		if(src.Anim_cellLayer !== void)
		{
			if(Anim_cellLayer === void)
				Anim_cellLayer = new global.KAGLayer(window, this);
			Anim_cellLayer.assignImages(src.Anim_cellLayer);
		}
		else
		{
			invalidate Anim_cellLayer if Anim_cellLayer !== void;
			Anim_cellLayer = void;
		}

		// 画像iみzみ情螭违偿冤`
		if(src.Anim_loadParams !== void)
		{
			Anim_loadParams = %[];
			(Dictionary.assign incontextof Anim_loadParams)(src.Anim_loadParams);
		}
		else
		{
			Anim_loadParams = void;
		}

		// 部分追加iみzみの情螭违偿冤`
		if(src.Anim_partialImageInfo !== void)
		{
			var destinfo;
			Anim_partialImageInfo = destinfo = [];
			var srcinfo = src.Anim_partialImageInfo;
			var count = srcinfo.count;
			for(var i = 0; i < count; i++)
			{
				var info = %[];
				(Dictionary.assign incontextof info)(srcinfo[i]);
				destinfo.add(info);
			}
		}
		else
		{
			Anim_partialImageInfo = void;
		}

		// アニメ`ションセグメント情螭违偿冤`

		// いったんF在のセグメントをクリア
		for(var i = Anim_segments.count -1; i>=0; i--)
		{
			var seg = Anim_segments[i];
			invalidate Anim_segments[i] if seg !== void;
		}

		var srcanimseg = src.Anim_segments; // エイリアス
		var src_animseg_count = srcanimseg.count;
		var animseg = Anim_segments; // エイリアス

		for(var i = src_animseg_count-1; i>=0; i--)
		{
			var seg = srcanimseg[i];
			animseg[i] = void;
			if(seg !== void)
			{
				animseg[i] = new AnimationConductor(this);
				animseg[i].number = i;
				animseg[i].assign(seg); // アサイン
			}
		}

		animseg.count = src_animseg_count;

		// その他
		Anim_interrupted = src.Anim_interrupted;
		Anim_storageName = src.Anim_storageName;
	}

	function store()
	{
		// 情螭虼配列にh
		var dic = super.store();

		// iみzみパラメ`タ
		if(Anim_loadParams !== void)
		{
			dic.loadParams = %[];
			(Dictionary.assign incontextof dic.loadParams)(Anim_loadParams);
		}
		else
		{
			dic.loadParams = void;
		}

		// 部分追加iみzみの情
		if(Anim_partialImageInfo !== void)
		{
			var dest;
			dic.partialImageInfo = dest = [];
			var src = Anim_partialImageInfo;
			var count = src.count;
			for(var i = 0; i < count; i++)
			{
				var info = %[];
				(Dictionary.assign incontextof info)(src[i]);
				dest.add(info);
			}
		}
		else
		{
			dic.partialImageInfo = void;
		}

		// アニメ`ションセグメントの情螭蛴h
		dic.segments = [];
		var animseg = Anim_segments; // エイリアス
		var animsegcount = animseg.count;
		for(var i = 1; i<animsegcount; i++)
		{
			var seg = animseg[i];
			if(seg !== void)
			{
				if(seg.looping && !seg.stopping && seg.running)
				{
					// ル`プ中でかつ停止していなくて停止待ちでもない龊
					var dat = %[];
					dat.label = seg.startLabel;
					dic.segments[i] = dat;
				}
			}
		}

		return dic;
	}

	function restore(dic)
	{
		// dic から情螭蛘iみ出す
		loadImages(dic.loadParams);
		if(dic.loadParams !== void)
		{
			// アニメ`ションセグメントの情螭驮
			var dicsegments = dic.segments;
			if(dicsegments !== void)
			{
				var dicsegmentscount = dicsegments.count;
				for(var i = 1; i < dicsegmentscount; i++)
				{
					var seg = dicsegments[i];
					if(seg !== void)
						loadAnimInfo(i, seg.label, true);
				}
			}
		}

		// 部分追加iみzみの情螭驮
		if(dic.partialImageInfo !== void)
		{
			var src = dic.partialImageInfo;
			var count = src.count;
			for(var i = 0; i < count; i++)
			{
				var o = src[i];
				var tagname = o.tagname;
				dm(tagname);
				var handler = global.AnimationLayer.Anim_reconstructHandlers[tagname];
				dm(handler);
				if(handler !== void)
					(handler incontextof this)(o);
			}
		}
		else
		{
			Anim_partialImageInfo = void;
		}

		super.restore(dic);
	}

	/*タグハンドラ*/function loadcell(elm)
	{
		// セルレイヤにセル画像をiみzむ

		// セルレイヤの_保
		if(Anim_cellLayer === void)
			Anim_cellLayer = new global.KAGLayer(window, this); // レイヤを作成

		// カラ`キ`のQ定
		var key;
		if(elm.key !== void)
		{
			// key 指定がある
			key = elm.key;
		}
		else
		{
			// key 指定がない
			key = Anim_loadParams.key; // loadParams の方の key を使う
		}

		// ストレ`ジ名のQ定
		var storage;
		if(elm.storage !== void)
		{
			// storage 指定がある
			storage = elm.storage;
		}
		else
		{
			// storage 指定がない
			storage = Storages.chopStorageExt(Anim_loadParams.storage) + "_a";
				// loadParams の storage を使う
		}

		// セルレイヤに画像をiみzむ
		Anim_cellLayer.loadImages(storage, key);

		// セルレイヤにして色{a正
		applyColorCorrection(Anim_cellLayer, Anim_loadParams);

		// フリップ
		if(Anim_loadParams.flipud !== void && +Anim_loadParams.flipud)
		{
			// 上下反
			Anim_cellLayer.flipUD();
		}
		if(Anim_loadParams.fliplr !== void && +Anim_loadParams.fliplr)
		{
			// 左右反
			Anim_cellLayer.flipLR();
		}

		return 0;
	}

	/*タグハンドラ*/function copy(elm)
	{
		var lp = Anim_loadParams;
		if(lp === void) return -1;
		var f;
		f = lp.flipud;
		var dx = +elm.dx;
		var dy = +elm.dy;
		var sx = +elm.sx;
		var sy = +elm.sy;
		var sw = +elm.sw;
		var sh = +elm.sh;
		var cl = Anim_cellLayer;
		if(f !== void && +f)
		{
			// 上下反
			dy = imageHeight - dy - sh;
			sy = cl.imageHeight - sy - sh;
		}
		f = lp.fliplr;
		if(f !== void && +f)
		{
			// 左右反
			dx = imageWidth - dx - sw;
			sx = cl.imageWidth - sx - sw;
		}

		face = dfAuto;
		copyRect(dx, dy, cl, sx, sy, sw, sh);

		return 0;
	}

	/*タグハンドラ*/function s(elm)
	{
		// 停止
		elm.context.running = false;
		window.onAnimationStopped(name, elm.context.number);
		return -1; // 停止
	}

	/*タグハンドラ*/function loop(elm)
	{
		// ル`プを行うことを宣言する
		elm.context.looping = true;
		return 0;
	}

	/*タグハンドラ*/function home(elm)
	{
		// ホ`ムポジション
		return elm.context.stopping?-1:0; // stopping に兢盲仆Ｖ
	}

	/*タグハンドラ*/function clip(elm)
	{
		// cliprect の涓
		setImagePos(-elm.left, -elm.top);
		return 0;
	}

	/*タグハンドラ*/function wait(elm)
	{
		return elm.time; // 指定rgだけ停止
	}

	/*タグハンドラ*/function eval(elm)
	{
		Scripts.eval(elm.exp); // elm.exp を式としてg行
		return 0;
	}


}


// pimage, ptext タグのように、荬握iみzみrに再B
// 可能な情螭驮するHに用いるハンドラ
// (タグ名と、それに辘工毳膝螗丧椁蛴述する)
AnimationLayer.Anim_reconstructHandlers =
	%[
		pimage	:	AnimationLayer.loadPartialImage,
		ptext	:	AnimationLayer.drawReconstructibleText
	];


class ClickGlyphLayer extends AnimationLayer
{
	// クリック待ち号レイヤ
	var loadedImage; // F在iみzまれている画像
	var loadedKey; // F在iみzまれているキ`

	function ClickGlyphLayer(win, par)
	{
		// コンストラクタ
		super.AnimationLayer(win, par);
		hitType = htMask;
		hitThreshold = 256; // マウスメッセ`ジは完全に透^
	}

	function finalize()
	{
		// finalize()
		super.finalize(...);
	}

	function loadImages(storage, key)
	{
		// loadImage オ`バ`ライド
		if(loadedImage !== storage || loadedKey !== key)
		{
			super.loadImages(%[storage : storage, key : key]);
			loadedImage = storage;
			loadedKey = key;
		}
	}

	property visible
	{
		// visible オ`バ`ライド
		getter()
		{
			return super.visible;
		}
		setter(x)
		{
			super.visible = x;
			// 非表示のrは幼鳏蛲Ｖ工筏皮い毪瑜Δ
			if(x)
				interrupted = false;
			else
				interrupted = true;
		}
	}
}



